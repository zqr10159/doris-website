"use strict";(self.webpackChunkdoris_website=self.webpackChunkdoris_website||[]).push([[211808],{15680:(e,a,t)=>{t.d(a,{xA:()=>m,yg:()=>c});var i=t(296540);function n(e,a,t){return a in e?Object.defineProperty(e,a,{value:t,enumerable:!0,configurable:!0,writable:!0}):e[a]=t,e}function r(e,a){var t=Object.keys(e);if(Object.getOwnPropertySymbols){var i=Object.getOwnPropertySymbols(e);a&&(i=i.filter((function(a){return Object.getOwnPropertyDescriptor(e,a).enumerable}))),t.push.apply(t,i)}return t}function l(e){for(var a=1;a<arguments.length;a++){var t=null!=arguments[a]?arguments[a]:{};a%2?r(Object(t),!0).forEach((function(a){n(e,a,t[a])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(t)):r(Object(t)).forEach((function(a){Object.defineProperty(e,a,Object.getOwnPropertyDescriptor(t,a))}))}return e}function s(e,a){if(null==e)return{};var t,i,n=function(e,a){if(null==e)return{};var t,i,n={},r=Object.keys(e);for(i=0;i<r.length;i++)t=r[i],a.indexOf(t)>=0||(n[t]=e[t]);return n}(e,a);if(Object.getOwnPropertySymbols){var r=Object.getOwnPropertySymbols(e);for(i=0;i<r.length;i++)t=r[i],a.indexOf(t)>=0||Object.prototype.propertyIsEnumerable.call(e,t)&&(n[t]=e[t])}return n}var o=i.createContext({}),d=function(e){var a=i.useContext(o),t=a;return e&&(t="function"==typeof e?e(a):l(l({},a),e)),t},m=function(e){var a=d(e.components);return i.createElement(o.Provider,{value:a},e.children)},p="mdxType",u={inlineCode:"code",wrapper:function(e){var a=e.children;return i.createElement(i.Fragment,{},a)}},h=i.forwardRef((function(e,a){var t=e.components,n=e.mdxType,r=e.originalType,o=e.parentName,m=s(e,["components","mdxType","originalType","parentName"]),p=d(t),h=n,c=p["".concat(o,".").concat(h)]||p[h]||u[h]||r;return t?i.createElement(c,l(l({ref:a},m),{},{components:t})):i.createElement(c,l({ref:a},m))}));function c(e,a){var t=arguments,n=a&&a.mdxType;if("string"==typeof e||n){var r=t.length,l=new Array(r);l[0]=h;var s={};for(var o in a)hasOwnProperty.call(a,o)&&(s[o]=a[o]);s.originalType=e,s[p]="string"==typeof e?e:n,l[1]=s;for(var d=2;d<r;d++)l[d]=t[d];return i.createElement.apply(null,l)}return i.createElement.apply(null,t)}h.displayName="MDXCreateElement"},493630:(e,a,t)=>{t.r(a),t.d(a,{assets:()=>o,contentTitle:()=>l,default:()=>u,frontMatter:()=>r,metadata:()=>s,toc:()=>d});var i=t(58168),n=(t(296540),t(15680));const r={title:"Asynchronous materialized view",language:"en"},l=void 0,s={unversionedId:"query/view-materialized-view/async-materialized-view",id:"version-3.0/query/view-materialized-view/async-materialized-view",title:"Asynchronous materialized view",description:"\x3c!--",source:"@site/versioned_docs/version-3.0/query/view-materialized-view/async-materialized-view.md",sourceDirName:"query/view-materialized-view",slug:"/query/view-materialized-view/async-materialized-view",permalink:"/docs/query/view-materialized-view/async-materialized-view",draft:!1,tags:[],version:"3.0",frontMatter:{title:"Asynchronous materialized view",language:"en"},sidebar:"docs",previous:{title:"Materialized View",permalink:"/docs/query/view-materialized-view/materialized-view"},next:{title:"Querying Async Materialized View",permalink:"/docs/query/view-materialized-view/query-async-materialized-view"}},o={},d=[{value:"Construction and maintenance of materialized views",id:"construction-and-maintenance-of-materialized-views",level:2},{value:"Create materialized views",id:"create-materialized-views",level:3},{value:"View materialized view meta information",id:"view-materialized-view-meta-information",level:3},{value:"Refresh materialized view",id:"refresh-materialized-view",level:3},{value:"Task management",id:"task-management",level:3},{value:"View jobs in materialized views",id:"view-jobs-in-materialized-views",level:4},{value:"Pause materialized view job scheduled scheduling",id:"pause-materialized-view-job-scheduled-scheduling",level:4},{value:"Resume materialized view job scheduling",id:"resume-materialized-view-job-scheduling",level:4},{value:"View tasks in materialized views",id:"view-tasks-in-materialized-views",level:4},{value:"Cancel the task of objectifying the view",id:"cancel-the-task-of-objectifying-the-view",level:4},{value:"Modify materialized views",id:"modify-materialized-views",level:3},{value:"Delete materialized view",id:"delete-materialized-view",level:3},{value:"Partition description",id:"partition-description",level:2},{value:"Custom partitioning",id:"custom-partitioning",level:3},{value:"Partitioning based on dependent base tables",id:"partitioning-based-on-dependent-base-tables",level:3},{value:"The base table has multiple partition columns",id:"the-base-table-has-multiple-partition-columns",level:4},{value:"Only using a subset of the base table partitions",id:"only-using-a-subset-of-the-base-table-partitions",level:4},{value:"Partition rolling up",id:"partition-rolling-up",level:4},{value:"List partition",id:"list-partition",level:5},{value:"Range partition",id:"range-partition",level:5},{value:"Data refreshing",id:"data-refreshing",level:2},{value:"Refresh principle",id:"refresh-principle",level:3},{value:"Trigger mechanism",id:"trigger-mechanism",level:3},{value:"Manual trigger",id:"manual-trigger",level:4},{value:"Scheduled trigger",id:"scheduled-trigger",level:4},{value:"Automatic trigger",id:"automatic-trigger",level:4},{value:"Problem localization",id:"problem-localization",level:2},{value:"Localization means",id:"localization-means",level:3},{value:"View materialized view metadata",id:"view-materialized-view-metadata",level:4},{value:"View tasks for the materialized view",id:"view-tasks-for-the-materialized-view",level:4},{value:"Common issues",id:"common-issues",level:3},{value:"Usage scenarios",id:"usage-scenarios",level:2},{value:"Query acceleration",id:"query-acceleration",level:3},{value:"Data lake acceleration",id:"data-lake-acceleration",level:3},{value:"Background of demand",id:"background-of-demand",level:4},{value:"Pain points",id:"pain-points",level:4},{value:"How to achieve appearance query acceleration",id:"how-to-achieve-appearance-query-acceleration",level:4},{value:"Data modeling",id:"data-modeling",level:3},{value:"The relationship between materialized views and olap",id:"the-relationship-between-materialized-views-and-olap",level:2},{value:"The use of materialized views",id:"the-use-of-materialized-views",level:2},{value:"Notice",id:"notice",level:2}],m={toc:d},p="wrapper";function u(e){let{components:a,...t}=e;return(0,n.yg)(p,(0,i.A)({},m,t,{components:a,mdxType:"MDXLayout"}),(0,n.yg)("h1",{id:"asynchronous-materialized-view"},"Asynchronous materialized view"),(0,n.yg)("h2",{id:"construction-and-maintenance-of-materialized-views"},"Construction and maintenance of materialized views"),(0,n.yg)("h3",{id:"create-materialized-views"},"Create materialized views"),(0,n.yg)("p",null,"Prepare two tables and data"),(0,n.yg)("pre",null,(0,n.yg)("code",{parentName:"pre",className:"language-sql"},"use tpch;\n\nCREATE TABLE IF NOT EXISTS orders  (\n    o_orderkey       integer not null,\n    o_custkey        integer not null,\n    o_orderstatus    char(1) not null,\n    o_totalprice     decimalv3(15,2) not null,\n    o_orderdate      date not null,\n    o_orderpriority  char(15) not null,\n    o_clerk          char(15) not null,\n    o_shippriority   integer not null,\n    o_comment        varchar(79) not null\n    )\n    DUPLICATE KEY(o_orderkey, o_custkey)\n    PARTITION BY RANGE(o_orderdate)(\n    FROM ('2023-10-17') TO ('2023-10-20') INTERVAL 1 DAY)\n    DISTRIBUTED BY HASH(o_orderkey) BUCKETS 3\n    PROPERTIES (\"replication_num\" = \"1\");\n\ninsert into orders values\n   (1, 1, 'ok', 99.5, '2023-10-17', 'a', 'b', 1, 'yy'),\n   (2, 2, 'ok', 109.2, '2023-10-18', 'c','d',2, 'mm'),\n   (3, 3, 'ok', 99.5, '2023-10-19', 'a', 'b', 1, 'yy');\n\nCREATE TABLE IF NOT EXISTS lineitem (\n    l_orderkey    integer not null,\n    l_partkey     integer not null,\n    l_suppkey     integer not null,\n    l_linenumber  integer not null,\n    l_quantity    decimalv3(15,2) not null,\n    l_extendedprice  decimalv3(15,2) not null,\n    l_discount    decimalv3(15,2) not null,\n    l_tax         decimalv3(15,2) not null,\n    l_returnflag  char(1) not null,\n    l_linestatus  char(1) not null,\n    l_shipdate    date not null,\n    l_commitdate  date not null,\n    l_receiptdate date not null,\n    l_shipinstruct char(25) not null,\n    l_shipmode     char(10) not null,\n    l_comment      varchar(44) not null\n    )\n    DUPLICATE KEY(l_orderkey, l_partkey, l_suppkey, l_linenumber)\n    PARTITION BY RANGE(l_shipdate)\n    (FROM ('2023-10-17') TO ('2023-10-20') INTERVAL 1 DAY)\n    DISTRIBUTED BY HASH(l_orderkey) BUCKETS 3\n    PROPERTIES (\"replication_num\" = \"1\");\n\ninsert into lineitem values\n (1, 2, 3, 4, 5.5, 6.5, 7.5, 8.5, 'o', 'k', '2023-10-17', '2023-10-17', '2023-10-17', 'a', 'b', 'yyyyyyyyy'),\n (2, 2, 3, 4, 5.5, 6.5, 7.5, 8.5, 'o', 'k', '2023-10-18', '2023-10-18', '2023-10-18', 'a', 'b', 'yyyyyyyyy'),\n (3, 2, 3, 6, 7.5, 8.5, 9.5, 10.5, 'k', 'o', '2023-10-19', '2023-10-19', '2023-10-19', 'c', 'd', 'xxxxxxxxx');\n")),(0,n.yg)("p",null,"Create materialized views"),(0,n.yg)("pre",null,(0,n.yg)("code",{parentName:"pre",className:"language-sql"},"CREATE MATERIALIZED VIEW mv1 \n        BUILD DEFERRED REFRESH AUTO ON MANUAL\n        partition by(l_shipdate)\n        DISTRIBUTED BY RANDOM BUCKETS 2\n        PROPERTIES ('replication_num' = '1') \n        AS \n        select l_shipdate, o_orderdate, l_partkey, l_suppkey, sum(o_totalprice) as sum_total\n            from lineitem\n            left join orders on lineitem.l_orderkey = orders.o_orderkey and l_shipdate = o_orderdate\n            group by\n            l_shipdate,\n            o_orderdate,\n            l_partkey,\n            l_suppkey;\n")),(0,n.yg)("p",null,"Specific syntax can be viewed ",(0,n.yg)("a",{parentName:"p",href:"/docs/sql-manual/sql-statements/Data-Definition-Statements/Create/CREATE-ASYNC-MATERIALIZED-VIEW"},"CREATE ASYNC MATERIALIZED VIEW")),(0,n.yg)("h3",{id:"view-materialized-view-meta-information"},"View materialized view meta information"),(0,n.yg)("pre",null,(0,n.yg)("code",{parentName:"pre",className:"language-sql"},'select * from mv_infos("database"="tpch") where Name="mv1";\n')),(0,n.yg)("p",null,"The unique features of materialized views can be viewed through ",(0,n.yg)("a",{parentName:"p",href:"/docs/sql-manual/sql-functions/table-functions/mv_infos"},"mv_infos()")),(0,n.yg)("p",null,"Properties related to table, still viewed through ",(0,n.yg)("a",{parentName:"p",href:"/docs/sql-manual/sql-statements/Show-Statements/SHOW-TABLES"},"SHOW TABLES")),(0,n.yg)("h3",{id:"refresh-materialized-view"},"Refresh materialized view"),(0,n.yg)("p",null,"The materialized view supports different refresh strategies, such as scheduled refresh and manual refresh. It also supports different refresh granularity, such as full refresh, incremental refresh of partition granularity, etc. Here we take manually refreshing partial partitions of the materialized view as an example."),(0,n.yg)("p",null,"First, check the list of materialized view partitions"),(0,n.yg)("pre",null,(0,n.yg)("code",{parentName:"pre",className:"language-sql"},"SHOW PARTITIONS FROM mv1;\n")),(0,n.yg)("p",null,"Refresh partition named ",(0,n.yg)("inlineCode",{parentName:"p"},"p_20231017_20231018")),(0,n.yg)("pre",null,(0,n.yg)("code",{parentName:"pre",className:"language-sql"},"REFRESH MATERIALIZED VIEW mv1 partitions(p_20231017_20231018);\n")),(0,n.yg)("p",null,"Specific syntax can be viewed ",(0,n.yg)("a",{parentName:"p",href:"/docs/sql-manual/sql-statements/Utility-Statements/REFRESH-MATERIALIZED-VIEW"},"REFRESH MATERIALIZED VIEW")),(0,n.yg)("h3",{id:"task-management"},"Task management"),(0,n.yg)("p",null,"Each materialized view defaults to a job responsible for refreshing data, which is used to describe the refresh strategy and other information of the materialized view. Each time a refresh is triggered, a task is generated,\nTask is used to describe specific refresh information, such as the time used for refreshing, which partitions were refreshed, etc"),(0,n.yg)("h4",{id:"view-jobs-in-materialized-views"},"View jobs in materialized views"),(0,n.yg)("pre",null,(0,n.yg)("code",{parentName:"pre",className:"language-sql"},'select * from jobs("type"="mv") order by CreateTime;\n')),(0,n.yg)("p",null,"Specific syntax can be viewed ",(0,n.yg)("a",{parentName:"p",href:"/docs/sql-manual/sql-functions/table-functions/jobs"},'jobs("type"="mv")')),(0,n.yg)("h4",{id:"pause-materialized-view-job-scheduled-scheduling"},"Pause materialized view job scheduled scheduling"),(0,n.yg)("pre",null,(0,n.yg)("code",{parentName:"pre",className:"language-sql"},"PAUSE MATERIALIZED VIEW JOB ON mv1;\n")),(0,n.yg)("p",null,"Can pause the scheduled scheduling of materialized views"),(0,n.yg)("p",null,"Specific syntax can be viewed ",(0,n.yg)("a",{parentName:"p",href:"/docs/sql-manual/sql-statements/Utility-Statements/PAUSE-MATERIALIZED-VIEW"},"PAUSE MATERIALIZED VIEW JOB")),(0,n.yg)("h4",{id:"resume-materialized-view-job-scheduling"},"Resume materialized view job scheduling"),(0,n.yg)("pre",null,(0,n.yg)("code",{parentName:"pre",className:"language-sql"},"RESUME MATERIALIZED VIEW JOB ON mv1;\n")),(0,n.yg)("p",null,"Can RESUME scheduled scheduling of materialized views"),(0,n.yg)("p",null,"Specific syntax can be viewed ",(0,n.yg)("a",{parentName:"p",href:"/docs/sql-manual/sql-statements/Utility-Statements/RESUME-MATERIALIZED-VIEW"},"RESUME MATERIALIZED VIEW JOB")),(0,n.yg)("h4",{id:"view-tasks-in-materialized-views"},"View tasks in materialized views"),(0,n.yg)("pre",null,(0,n.yg)("code",{parentName:"pre",className:"language-sql"},'select * from tasks("type"="mv");\n')),(0,n.yg)("p",null,"Specific syntax can be viewed ",(0,n.yg)("a",{parentName:"p",href:"/docs/sql-manual/sql-functions/table-functions/tasks"},'tasks("type"="mv")')),(0,n.yg)("h4",{id:"cancel-the-task-of-objectifying-the-view"},"Cancel the task of objectifying the view"),(0,n.yg)("pre",null,(0,n.yg)("code",{parentName:"pre",className:"language-sql"},"CANCEL MATERIALIZED VIEW TASK realTaskId on mv1;\n")),(0,n.yg)("p",null,"Can cancel the operation of this task"),(0,n.yg)("p",null,"Specific syntax can be viewed ",(0,n.yg)("a",{parentName:"p",href:"/docs/sql-manual/sql-statements/Utility-Statements/CANCEL-MATERIALIZED-VIEW-TASK"},"CANCEL MATERIALIZED VIEW TASK")),(0,n.yg)("h3",{id:"modify-materialized-views"},"Modify materialized views"),(0,n.yg)("p",null,"Modify the properties of materialized views"),(0,n.yg)("pre",null,(0,n.yg)("code",{parentName:"pre",className:"language-sql"},'ALTER MATERIALIZED VIEW mv1 set("grace_period"="3333");\n')),(0,n.yg)("p",null,"Modify the name of the materialized view, the refresh method of the materialized view, and the unique properties of the materialized view can be viewed through ",(0,n.yg)("a",{parentName:"p",href:"/docs/sql-manual/sql-statements/Data-Definition-Statements/Alter/ALTER-ASYNC-MATERIALIZED-VIEW"},"ALTER ASYNC MATERIALIZED VIEW")),(0,n.yg)("p",null,"The materialized view itself is also a Table, so Table related properties, such as the number of copies, are still modified through the syntax related to ",(0,n.yg)("inlineCode",{parentName:"p"},"ALTER TABLE"),"."),(0,n.yg)("h3",{id:"delete-materialized-view"},"Delete materialized view"),(0,n.yg)("pre",null,(0,n.yg)("code",{parentName:"pre",className:"language-sql"},"DROP MATERIALIZED VIEW mv1;\n")),(0,n.yg)("p",null,"The materialized view has a dedicated deletion syntax and cannot be deleted through the drop table,"),(0,n.yg)("p",null,"Specific syntax can be viewed ",(0,n.yg)("a",{parentName:"p",href:"/docs/sql-manual/sql-statements/Data-Definition-Statements/Drop/DROP-ASYNC-MATERIALIZED-VIEW"},"DROP ASYNC MATERIALIZED VIEW")),(0,n.yg)("h2",{id:"partition-description"},"Partition description"),(0,n.yg)("p",null,"There are two ways to partition materialized views:"),(0,n.yg)("ol",null,(0,n.yg)("li",{parentName:"ol"},(0,n.yg)("p",{parentName:"li"},"Custom Partitioning")),(0,n.yg)("li",{parentName:"ol"},(0,n.yg)("p",{parentName:"li"},"Automatically Create Partitions Based on Dependent Base Table Partitions"))),(0,n.yg)("h3",{id:"custom-partitioning"},"Custom partitioning"),(0,n.yg)("p",null,"When creating a materialized view without specifying partition information, the materialized view will default to creating a single partition where all data will be stored."),(0,n.yg)("h3",{id:"partitioning-based-on-dependent-base-tables"},"Partitioning based on dependent base tables"),(0,n.yg)("p",null,"A materialized view can be created by joining multiple base tables."),(0,n.yg)("p",null,"A materialized view can be partitioned to follow one of the base tables (it is recommended to choose the fact table)."),(0,n.yg)("p",null,"For example"),(0,n.yg)("p",null,"The table creation statement for t1 is as follows:"),(0,n.yg)("pre",null,(0,n.yg)("code",{parentName:"pre",className:"language-sql"},"CREATE TABLE `t1` (\n  `user_id` LARGEINT NOT NULL,\n  `o_date` DATE NOT NULL,\n  `num` SMALLINT NOT NULL\n) ENGINE=OLAP\nCOMMENT 'OLAP'\nPARTITION BY RANGE(`o_date`)\n(\nPARTITION p20170101 VALUES [('2017-01-01'), ('2017-01-02')),\nPARTITION p20170102 VALUES [('2017-01-02'), ('2017-01-03')),\nPARTITION p20170201 VALUES [('2017-02-01'), ('2017-02-02'))\n)\nDISTRIBUTED BY HASH(`user_id`) BUCKETS 2\nPROPERTIES ('replication_num' = '1') ;\n")),(0,n.yg)("p",null,"The table creation statement for t2 is as follows:"),(0,n.yg)("pre",null,(0,n.yg)("code",{parentName:"pre",className:"language-sql"},"CREATE TABLE `t2` (\n  `user_id` LARGEINT NOT NULL,\n  `age` SMALLINT NOT NULL\n) ENGINE=OLAP\nPARTITION BY LIST(`age`)\n(\n    PARTITION `p1` VALUES IN ('1'),\n    PARTITION `p2` VALUES IN ('2')\n)\nDISTRIBUTED BY HASH(`user_id`) BUCKETS 2\nPROPERTIES ('replication_num' = '1') ;\n")),(0,n.yg)("p",null,"If the materialized view creation statement is as follows, then the materialized view mv1 will have the same three partitions as t1:"),(0,n.yg)("ul",null,(0,n.yg)("li",{parentName:"ul"},"[('2017-01-01'), ('2017-01-02'))"),(0,n.yg)("li",{parentName:"ul"},"[('2017-01-02'), ('2017-01-03'))"),(0,n.yg)("li",{parentName:"ul"},"[('2017-02-01'), ('2017-02-02'))")),(0,n.yg)("pre",null,(0,n.yg)("code",{parentName:"pre",className:"language-sql"},"CREATE MATERIALIZED VIEW mv1\nBUILD DEFERRED REFRESH AUTO ON MANUAL\npartition by(`order_date`)\nDISTRIBUTED BY RANDOM BUCKETS 2\nPROPERTIES (\n'replication_num' = '1'\n)\nAS\nSELECT t1.o_date as order_date, t1.user_id as user_id, t1.num, t2.age FROM t1 join t2 on t1.user_id=t2.user_id;\n")),(0,n.yg)("p",null,"If the materialized view creation statement is as follows, then the materialized view mv2 will have the same three partitions as t2:"),(0,n.yg)("ul",null,(0,n.yg)("li",{parentName:"ul"},"('1')"),(0,n.yg)("li",{parentName:"ul"},"('2')")),(0,n.yg)("pre",null,(0,n.yg)("code",{parentName:"pre",className:"language-sql"},"CREATE MATERIALIZED VIEW mv2\nBUILD DEFERRED REFRESH AUTO ON MANUAL\npartition by(`age`)\nDISTRIBUTED BY RANDOM BUCKETS 2\nPROPERTIES (\n'replication_num' = '1'\n)\nAS\nSELECT t1.o_date as order_date, t1.user_id as user_id, t1.num, t2.age FROM t1 join t2 on t1.user_id=t2.user_id;\n")),(0,n.yg)("h4",{id:"the-base-table-has-multiple-partition-columns"},"The base table has multiple partition columns"),(0,n.yg)("p",null,"Currently, only Hive external tables support multiple partition columns."),(0,n.yg)("p",null,"Hive external tables often have multi-level partitions. For example, the first-level partition is by date, and the second-level partition is by region."),(0,n.yg)("p",null,"A materialized view can choose one of the partition columns from a Hive table as the partition column for the materialized view."),(0,n.yg)("p",null,"For example, the Hive table creation statement is as follows:"),(0,n.yg)("pre",null,(0,n.yg)("code",{parentName:"pre",className:"language-sql"},'CREATE TABLE hive1 (\n`k1` int)\nPARTITIONED BY (\n`year` int,\n`region` string)\nSTORED AS ORC;\n\nalter table hive1 add if not exists\npartition(year=2020,region="bj")\npartition(year=2020,region="sh")\npartition(year=2021,region="bj")\npartition(year=2021,region="sh")\npartition(year=2022,region="bj")\npartition(year=2022,region="sh")\n')),(0,n.yg)("p",null,"If the materialized view creation statement is as follows, then the materialized view mv_hive will have the following three partitions:"),(0,n.yg)("ul",null,(0,n.yg)("li",{parentName:"ul"},"('2020')"),(0,n.yg)("li",{parentName:"ul"},"('2021')"),(0,n.yg)("li",{parentName:"ul"},"('2022')")),(0,n.yg)("pre",null,(0,n.yg)("code",{parentName:"pre",className:"language-sql"},"CREATE MATERIALIZED VIEW mv_hive\nBUILD DEFERRED REFRESH AUTO ON MANUAL\npartition by(`year`)\nDISTRIBUTED BY RANDOM BUCKETS 2\nPROPERTIES ('replication_num' = '1')\nAS\nSELECT k1,year,region FROM hive1;\n")),(0,n.yg)("p",null,"If the materialized view creation statement is as follows, then the materialized view mv_hive2 will have the following two partitions:"),(0,n.yg)("ul",null,(0,n.yg)("li",{parentName:"ul"},"('bj')"),(0,n.yg)("li",{parentName:"ul"},"('sh')")),(0,n.yg)("pre",null,(0,n.yg)("code",{parentName:"pre",className:"language-sql"},"CREATE MATERIALIZED VIEW mv_hive2\nBUILD DEFERRED REFRESH AUTO ON MANUAL\npartition by(`region`)\nDISTRIBUTED BY RANDOM BUCKETS 2\nPROPERTIES ('replication_num' = '1')\nAS\nSELECT k1,year,region FROM hive1;\n")),(0,n.yg)("h4",{id:"only-using-a-subset-of-the-base-table-partitions"},"Only using a subset of the base table partitions"),(0,n.yg)("p",null,"Note: Supported from version 2.1.1"),(0,n.yg)("p",null,'If some base tables have many partitions, but the materialized view only focuses on the recent "hot" data, this feature can be used.'),(0,n.yg)("p",null,"If the base table creation statement is as follows:"),(0,n.yg)("pre",null,(0,n.yg)("code",{parentName:"pre",className:"language-sql"},'CREATE TABLE t1 (\n    `k1` INT,\n    `k2` DATE NOT NULL\n) ENGINE=OLAP\nDUPLICATE KEY(`k1`)\nCOMMENT \'OLAP\'\nPARTITION BY range(`k2`)\n(\nPARTITION p26 VALUES [("2024-03-26"),("2024-03-27")),\nPARTITION p27 VALUES [("2024-03-27"),("2024-03-28")),\nPARTITION p28 VALUES [("2024-03-28"),("2024-03-29"))\n)\nDISTRIBUTED BY HASH(`k1`) BUCKETS 2\nPROPERTIES (\n\'replication_num\' = \'1\'\n);\n')),(0,n.yg)("p",null,"If the creation statement of the materialized view is as follows, it means that the materialized view only focuses on the data of the most recent day. If the current time is 2024-03-28 xx: xx: xx, then the materialized view will only have one partition ",'[("2024-03-28"), ("2024-03-29")]'),(0,n.yg)("pre",null,(0,n.yg)("code",{parentName:"pre",className:"language-sql"},"CREATE MATERIALIZED VIEW mv1\nBUILD DEFERRED REFRESH AUTO ON MANUAL\npartition by(`k2`)\nDISTRIBUTED BY RANDOM BUCKETS 2\nPROPERTIES (\n'replication_num' = '1',\n'partition_sync_limit'='1',\n'partition_sync_time_unit'='DAY'\n)\nAS\nSELECT * FROM t1;\n")),(0,n.yg)("p",null,"If another day has passed and the current time is 2024-03-29 xx: xx: xx, t1 adds a partition ",'[("2024-03-29"), ("2024-03-30")]',". If the materialized view is refreshed at this time, after the refresh is completed, the materialized view will only have one partition ",'[("2024-03-29"), ("2024-03-30")]'),(0,n.yg)("p",null,"If the partition field is of string type, you can set the materialized view property 'partition_date_format', for example, '%Y-%m-%d'."),(0,n.yg)("h4",{id:"partition-rolling-up"},"Partition rolling up"),(0,n.yg)("p",null,"Partition rolling up can be used when the data in each partition of the base table becomes very small after aggregation. This can reduce the number of partitions in the materialized view."),(0,n.yg)("h5",{id:"list-partition"},"List partition"),(0,n.yg)("p",null,"Note: Hive partitions correspond to Doris list partitions."),(0,n.yg)("p",null,"If the base table creation statement is as follows"),(0,n.yg)("pre",null,(0,n.yg)("code",{parentName:"pre",className:"language-sql"},"CREATE TABLE `t1` (\n  `k1` INT NOT NULL,\n  `k2` DATE NOT NULL\n) ENGINE=OLAP\nDUPLICATE KEY(`k1`)\nCOMMENT 'OLAP'\nPARTITION BY list(`k2`)\n(\nPARTITION p_20200101 VALUES IN (\"2020-01-01\"),\nPARTITION p_20200102 VALUES IN (\"2020-01-02\"),\nPARTITION p_20200201 VALUES IN (\"2020-02-01\")\n)\nDISTRIBUTED BY HASH(`k1`) BUCKETS 2\nPROPERTIES ('replication_num' = '1') ;\n")),(0,n.yg)("p",null,"If the materialized view creation statement is as follows, then the materialized view will have two partitions:"),(0,n.yg)("ul",null,(0,n.yg)("li",{parentName:"ul"},'("2020-01-01","2020-01-02")'),(0,n.yg)("li",{parentName:"ul"},'("2020-02-01")')),(0,n.yg)("pre",null,(0,n.yg)("code",{parentName:"pre",className:"language-sql"},"CREATE MATERIALIZED VIEW mv1\n    BUILD DEFERRED REFRESH AUTO ON MANUAL\n    partition by (date_trunc(`k2`,'month'))\n    DISTRIBUTED BY RANDOM BUCKETS 2\n    PROPERTIES (\n    'replication_num' = '1'\n    )\n    AS\n    SELECT * FROM t1;\n")),(0,n.yg)("p",null,"If the materialized view creation statement is as follows, then the materialized view will have one partition:"),(0,n.yg)("ul",null,(0,n.yg)("li",{parentName:"ul"},'("2020-01-01","2020-01-02","2020-02-01")')),(0,n.yg)("pre",null,(0,n.yg)("code",{parentName:"pre",className:"language-sql"},"CREATE MATERIALIZED VIEW mv1\n    BUILD DEFERRED REFRESH AUTO ON MANUAL\n    partition by (date_trunc(`k2`,'year'))\n    DISTRIBUTED BY RANDOM BUCKETS 2\n    PROPERTIES (\n    'replication_num' = '1'\n    )\n    AS\n    SELECT * FROM t1;\n")),(0,n.yg)("h5",{id:"range-partition"},"Range partition"),(0,n.yg)("p",null,"If the base table creation statement is as follows:"),(0,n.yg)("pre",null,(0,n.yg)("code",{parentName:"pre",className:"language-sql"},'CREATE TABLE `t1` (\n  `k1` LARGEINT NOT NULL,\n  `k2` DATE NOT NULL\n) ENGINE=OLAP\nDUPLICATE KEY(`k1`)\nCOMMENT \'OLAP\'\nPARTITION BY range(`k2`)\n(\nPARTITION p_20200101 VALUES [("2020-01-01"),("2020-01-02")),\nPARTITION p_20200102 VALUES [("2020-01-02"),("2020-01-03")),\nPARTITION p_20200201 VALUES [("2020-02-01"),("2020-02-02"))\n)\nDISTRIBUTED BY HASH(`k1`) BUCKETS 2\nPROPERTIES (\'replication_num\' = \'1\') ;\n')),(0,n.yg)("p",null,"If the materialized view creation statement is as follows, then the materialized view will have two partitions:"),(0,n.yg)("ul",null,(0,n.yg)("li",{parentName:"ul"},'[("2020-01-01","2020-02-01"))'),(0,n.yg)("li",{parentName:"ul"},'[("2020-02-01","2020-03-01"))')),(0,n.yg)("pre",null,(0,n.yg)("code",{parentName:"pre",className:"language-sql"},"CREATE MATERIALIZED VIEW mv1\n    BUILD DEFERRED REFRESH AUTO ON MANUAL\n    partition by (date_trunc(`k2`,'month'))\n    DISTRIBUTED BY RANDOM BUCKETS 2\n    PROPERTIES (\n    'replication_num' = '1'\n    )\n    AS\n    SELECT * FROM t1;\n")),(0,n.yg)("p",null,"If the materialized view creation statement is as follows, then the materialized view will have one partition:"),(0,n.yg)("ul",null,(0,n.yg)("li",{parentName:"ul"},'[("2020-01-01","2021-01-01"))')),(0,n.yg)("pre",null,(0,n.yg)("code",{parentName:"pre",className:"language-sql"},"CREATE MATERIALIZED VIEW mv1\n    BUILD DEFERRED REFRESH AUTO ON MANUAL\n    partition by (date_trunc(`k2`,'year'))\n    DISTRIBUTED BY RANDOM BUCKETS 2\n    PROPERTIES (\n    'replication_num' = '1'\n    )\n    AS\n    SELECT * FROM t1;\n")),(0,n.yg)("p",null,"Note: When the partition is a string, the way it is rolled up is still being designed. The current behavior may change, it is best not to use it"),(0,n.yg)("h2",{id:"data-refreshing"},"Data refreshing"),(0,n.yg)("h3",{id:"refresh-principle"},"Refresh principle"),(0,n.yg)("p",null,"The materialized view is refreshed on a per-partition basis. If the materialized view does not specify partitions, then each refresh will refresh the default partition of the materialized view, effectively refreshing all the data in the materialized view."),(0,n.yg)("h3",{id:"trigger-mechanism"},"Trigger mechanism"),(0,n.yg)("p",null,"There are three trigger refresh mechanisms for materialized views:"),(0,n.yg)("h4",{id:"manual-trigger"},"Manual trigger"),(0,n.yg)("p",null,"Users trigger the refresh of the materialized view through SQL statements. Currently, there are three strategies:"),(0,n.yg)("ol",null,(0,n.yg)("li",{parentName:"ol"},"Not concerned with which partitions are refreshed, but requires that after the refresh is complete, the data in the materialized view is synchronized with the base table.")),(0,n.yg)("pre",null,(0,n.yg)("code",{parentName:"pre",className:"language-sql"},"REFRESH MATERIALIZED VIEW mvName AUTO;\n")),(0,n.yg)("ol",{start:2},(0,n.yg)("li",{parentName:"ol"},"Regardless of the existing data in the materialized view, refresh all partitions of the materialized view.")),(0,n.yg)("pre",null,(0,n.yg)("code",{parentName:"pre",className:"language-sql"},"REFRESH MATERIALIZED VIEW mvName COMPLETE;\n")),(0,n.yg)("ol",{start:3},(0,n.yg)("li",{parentName:"ol"},"Regardless of the existing data in the materialized view, only refresh the specified partitions.")),(0,n.yg)("pre",null,(0,n.yg)("code",{parentName:"pre",className:"language-sql"},"REFRESH MATERIALIZED VIEW mvName partitions(partitionName1,partitionName2);\n")),(0,n.yg)("p",null,(0,n.yg)("inlineCode",{parentName:"p"},"partitionName")," can be obtained through ",(0,n.yg)("inlineCode",{parentName:"p"},"show partitions from mvName"),"."),(0,n.yg)("h4",{id:"scheduled-trigger"},"Scheduled trigger"),(0,n.yg)("p",null,"Specify how often to refresh the data through the creation statement of the materialized view."),(0,n.yg)("ol",null,(0,n.yg)("li",{parentName:"ol"},"If the materialized view creation statement is as follows, and it requires a full refresh (refresh complete), then the materialized view is refreshed every 10 hours, and all partitions of the materialized view are refreshed.")),(0,n.yg)("pre",null,(0,n.yg)("code",{parentName:"pre",className:"language-sql"},"CREATE MATERIALIZED VIEW mv1\nREFRESH COMPLETE ON SCHEDULE EVERY 10 hour\npartition by(`xxx`)\nAS\nselect ...;\n")),(0,n.yg)("ol",{start:2},(0,n.yg)("li",{parentName:"ol"},"If the materialized view creation statement is as follows, and it requires an automatic full refresh (refresh auto), then the materialized view is refreshed every 10 hours, and the partitions to be refreshed are automatically calculated (starting from version 2.1.3, automatic calculation of partitions to be refreshed is supported for Hive)")),(0,n.yg)("pre",null,(0,n.yg)("code",{parentName:"pre",className:"language-sql"},"CREATE MATERIALIZED VIEW mv1\nREFRESH AUTO ON SCHEDULE EVERY 10 hour\npartition by(`xxx`)\nAS\nselect ...;\n")),(0,n.yg)("h4",{id:"automatic-trigger"},"Automatic trigger"),(0,n.yg)("p",null,"Note: Supported from version 2.1.4"),(0,n.yg)("p",null,"After changes occur in the base table data, automatically trigger the refresh of related materialized views, with the same partition range as specified for ",(0,n.yg)("inlineCode",{parentName:"p"},"scheduled trigger"),"."),(0,n.yg)("p",null,"If the materialized view creation statement is as follows, then when there are changes in the data of t1, the materialized view will be automatically refreshed:"),(0,n.yg)("pre",null,(0,n.yg)("code",{parentName:"pre",className:"language-sql"},"CREATE MATERIALIZED VIEW mv1\nREFRESH ON COMMIT\npartition by(`xxx`)\nAS\nselect ... from t1;\n")),(0,n.yg)("h2",{id:"problem-localization"},"Problem localization"),(0,n.yg)("h3",{id:"localization-means"},"Localization means"),(0,n.yg)("p",null,"The commonly used commands for ",(0,n.yg)("inlineCode",{parentName:"p"},"olapTable")," are also applicable to materialized views, such as ",(0,n.yg)("inlineCode",{parentName:"p"},"show partitions"),", ",(0,n.yg)("inlineCode",{parentName:"p"},"desc table"),", ",(0,n.yg)("inlineCode",{parentName:"p"},"show data"),", etc."),(0,n.yg)("p",null,"The unique commands for materialized views mainly include the following:"),(0,n.yg)("h4",{id:"view-materialized-view-metadata"},"View materialized view metadata"),(0,n.yg)("p",null,(0,n.yg)("a",{parentName:"p",href:"../../sql-manual/sql-functions/table-functions/mv_infos"},"mv_infos()")),(0,n.yg)("p",null,"Focus on the following fields:"),(0,n.yg)("ul",null,(0,n.yg)("li",{parentName:"ul"},"State: If the state changes to SCHEMA_CHANGE, it means the schema of the base table has changed. In this case, the materialized view cannot be used for transparent rewriting (but direct querying of the materialized view is not affected). If the next refresh task is successful, the state will be restored to NORMAL."),(0,n.yg)("li",{parentName:"ul"},"SchemaChangeDetail: The reason for the SCHEMA_CHANGE."),(0,n.yg)("li",{parentName:"ul"},"RefreshState: The status of the last refresh task of the materialized view. If it is FAIL, it means the execution failed, and further localization can be done through tasks()."),(0,n.yg)("li",{parentName:"ul"},"SyncWithBaseTables: Whether the materialized view is synchronized with the base table data. If not synchronized, further determination can be made by using show partitions to identify which partition is not synchronized.")),(0,n.yg)("h4",{id:"view-tasks-for-the-materialized-view"},"View tasks for the materialized view"),(0,n.yg)("p",null,(0,n.yg)("a",{parentName:"p",href:"/docs/sql-manual/sql-functions/table-functions/tasks"},'tasks("type"="mv")')),(0,n.yg)("p",null,"Focus on the following fields:"),(0,n.yg)("ul",null,(0,n.yg)("li",{parentName:"ul"},"Status: If it is FAILED, it means the task execution failed. You can check the reason for failure through ErrorMsg. You can also search Doris logs using LastQueryId to get more detailed error information."),(0,n.yg)("li",{parentName:"ul"},"ErrorMsg: The reason for the failure."),(0,n.yg)("li",{parentName:"ul"},"DurationMs: The duration of the task execution."),(0,n.yg)("li",{parentName:"ul"},"TaskContext: The context of the task, where you can see the trigger information for the task."),(0,n.yg)("li",{parentName:"ul"},"RefreshMode: ",(0,n.yg)("inlineCode",{parentName:"li"},"complete")," indicates that all partitions were refreshed, ",(0,n.yg)("inlineCode",{parentName:"li"},"PARTIAL")," indicates that some partitions were refreshed, and ",(0,n.yg)("inlineCode",{parentName:"li"},"NOT_REFRESH")," indicates that no partitions needed to be refreshed.")),(0,n.yg)("h3",{id:"common-issues"},"Common issues"),(0,n.yg)("ol",null,(0,n.yg)("li",{parentName:"ol"},(0,n.yg)("p",{parentName:"li"},"How does the materialized view determine which partitions need to be refreshed?"),(0,n.yg)("p",{parentName:"li"},"Doris internally calculates the correspondence between the partitions of the materialized view and the base table, and records the version of the base table partitions used by the materialized view since the last successful refresh. For example, if the materialized view ",(0,n.yg)("inlineCode",{parentName:"p"},"mv1")," is created from base tables ",(0,n.yg)("inlineCode",{parentName:"p"},"t1")," and ",(0,n.yg)("inlineCode",{parentName:"p"},"t2"),", and it is partitioned based on ",(0,n.yg)("inlineCode",{parentName:"p"},"t1"),", the mapping between the partitions of ",(0,n.yg)("inlineCode",{parentName:"p"},"t1")," and ",(0,n.yg)("inlineCode",{parentName:"p"},"mv1")," is maintained."),(0,n.yg)("p",{parentName:"li"},"Assuming partition ",(0,n.yg)("inlineCode",{parentName:"p"},"p202003")," of ",(0,n.yg)("inlineCode",{parentName:"p"},"mv1")," corresponds to partitions ",(0,n.yg)("inlineCode",{parentName:"p"},"p20200301")," and ",(0,n.yg)("inlineCode",{parentName:"p"},"p20200302")," of ",(0,n.yg)("inlineCode",{parentName:"p"},"t1"),", after refreshing ",(0,n.yg)("inlineCode",{parentName:"p"},"p202003"),", Doris will record partitions ",(0,n.yg)("inlineCode",{parentName:"p"},"p20200301")," and ",(0,n.yg)("inlineCode",{parentName:"p"},"p20200302"),", as well as the current version of table ",(0,n.yg)("inlineCode",{parentName:"p"},"t2"),"."),(0,n.yg)("p",{parentName:"li"},"When refreshing next time, Doris will check if ",(0,n.yg)("inlineCode",{parentName:"p"},"p20200301"),", ",(0,n.yg)("inlineCode",{parentName:"p"},"p20200302"),", or the version of ",(0,n.yg)("inlineCode",{parentName:"p"},"t2")," has changed. If any of them has changed, it means that ",(0,n.yg)("inlineCode",{parentName:"p"},"p202003")," needs to be refreshed."),(0,n.yg)("p",{parentName:"li"},"Of course, if it is acceptable for the business that ",(0,n.yg)("inlineCode",{parentName:"p"},"t2")," changes do not trigger a refresh of ",(0,n.yg)("inlineCode",{parentName:"p"},"mv1"),", you can set this through the materialized view's property ",(0,n.yg)("inlineCode",{parentName:"p"},"excluded_trigger_tables"),".")),(0,n.yg)("li",{parentName:"ol"},(0,n.yg)("p",{parentName:"li"},"What to do if the materialized view consumes too many resources and affects other business operations?"),(0,n.yg)("p",{parentName:"li"},"You can control the resources used by materialized view refresh tasks by specifying the ",(0,n.yg)("inlineCode",{parentName:"p"},"workload_group")," property of the materialized view."),(0,n.yg)("p",{parentName:"li"},"It's important to note that if the memory is set too low and a single partition refresh requires a significant amount of memory, the task may fail. It's necessary to balance these considerations based on the business requirements.")),(0,n.yg)("li",{parentName:"ol"},(0,n.yg)("p",{parentName:"li"},"Can new materialized views be created based on existing materialized views?"),(0,n.yg)("p",{parentName:"li"},"Yes, it's possible. Support for this feature started from version 2.1.3. However, when refreshing data, each materialized view has its own separate refresh logic."),(0,n.yg)("p",{parentName:"li"},"For example, ",(0,n.yg)("inlineCode",{parentName:"p"},"mv2")," is created based on ",(0,n.yg)("inlineCode",{parentName:"p"},"mv1"),", and ",(0,n.yg)("inlineCode",{parentName:"p"},"mv1")," is based on ",(0,n.yg)("inlineCode",{parentName:"p"},"t1"),"."),(0,n.yg)("p",{parentName:"li"},"Then when ",(0,n.yg)("inlineCode",{parentName:"p"},"mv2")," is refreshed, it will not consider whether ",(0,n.yg)("inlineCode",{parentName:"p"},"mv1")," is synchronized with ",(0,n.yg)("inlineCode",{parentName:"p"},"t1"),".")),(0,n.yg)("li",{parentName:"ol"},(0,n.yg)("p",{parentName:"li"},"What external tables are supported?"),(0,n.yg)("p",{parentName:"li"},"All external tables supported by Doris can be used to create materialized views. However, currently only Hive supports partitioned refresh, with support for other types expected to be added gradually.")),(0,n.yg)("li",{parentName:"ol"},(0,n.yg)("p",{parentName:"li"},"The materialized view appears to be consistent with the data in Hive, but in reality, it is not consistent."),(0,n.yg)("p",{parentName:"li"},"The materialized view can only guarantee that its data is consistent with the results queried through the catalog."),(0,n.yg)("p",{parentName:"li"},"The catalog has certain metadata and data caching."),(0,n.yg)("p",{parentName:"li"},"If you want the materialized view to be consistent with the data in Hive, you need to ensure that the catalog's data is consistent with Hive's data by using methods like ",(0,n.yg)("inlineCode",{parentName:"p"},"refresh catalog"),".")),(0,n.yg)("li",{parentName:"ol"},(0,n.yg)("p",{parentName:"li"},"Does the materialized view support schema changes?"),(0,n.yg)("p",{parentName:"li"},"It does not support modification because the column properties of the materialized view are derived from the SQL definition of the materialized view. Explicit customization is not currently supported.")),(0,n.yg)("li",{parentName:"ol"},(0,n.yg)("p",{parentName:"li"},"Can the base table used by a materialized view allow schema changes?"),(0,n.yg)("p",{parentName:"li"},"Yes, it is allowed. However, after the change, the ",(0,n.yg)("inlineCode",{parentName:"p"},"State")," of the materialized views that use the base table will change from ",(0,n.yg)("inlineCode",{parentName:"p"},"NORMAL")," to ",(0,n.yg)("inlineCode",{parentName:"p"},"SCHEMA_CHANGE"),". In this state, the materialized view cannot be used for transparent rewriting, but direct queries to the materialized view are not affected."),(0,n.yg)("p",{parentName:"li"},"If the next refresh task of the materialized view is successful, the ",(0,n.yg)("inlineCode",{parentName:"p"},"State")," will change back from ",(0,n.yg)("inlineCode",{parentName:"p"},"SCHEMA_CHANGE")," to ",(0,n.yg)("inlineCode",{parentName:"p"},"NORMAL"),".")),(0,n.yg)("li",{parentName:"ol"},(0,n.yg)("p",{parentName:"li"},"Can tables with a primary key model be used to create materialized views?"),(0,n.yg)("p",{parentName:"li"},"Materialized views do not have specific requirements regarding the data model of the base table. However, the materialized view itself can only have a detailed model.")),(0,n.yg)("li",{parentName:"ol"},(0,n.yg)("p",{parentName:"li"},"Can indexes be created on materialized views?"),(0,n.yg)("p",{parentName:"li"},"Yes, you can create indexes on materialized views.")),(0,n.yg)("li",{parentName:"ol"},(0,n.yg)("p",{parentName:"li"},"Does the table get locked when refreshing a materialized view?"),(0,n.yg)("p",{parentName:"li"},"At a very small stage, the table will be locked and will not continuously occupy the table lock (almost equivalent to the lock time of importing data)")),(0,n.yg)("li",{parentName:"ol"},(0,n.yg)("p",{parentName:"li"},"Is materialized views suitable for near real-time scenarios?"),(0,n.yg)("p",{parentName:"li"},"Not very suitable. The minimum unit for refreshing materialized views is the partition. If the data volume is large, it will occupy more resources and not be real-time enough. Consider synchronizing materialized views or other means."))),(0,n.yg)("h2",{id:"usage-scenarios"},"Usage scenarios"),(0,n.yg)("h3",{id:"query-acceleration"},"Query acceleration"),(0,n.yg)("p",null,"For BI report scenarios and other acceleration scenarios, queries are usually performed by joining multiple tables and then aggregating them. Users are sensitive to the response time of queries and generally need to return multiple query results at the second level, which consumes a lot of computing resources and sometimes makes it difficult to ensure the expected response time. In this case, multi table materialized views can solve this problem."),(0,n.yg)("p",null,"Materialized views are effective in accelerating repetitive and regular queries. The materialized view supports both direct querying and transparent rewriting. Transparent rewriting refers to the use of a set of materialized views, and the optimizer automatically selects the optimal materialized view available to respond to queries based on the rewriting algorithm and cost model."),(0,n.yg)("p",null,"Use the pre computed results of materialized views to respond to queries. Greatly reduces the resources used for table connections and aggregation operations, and reduces query response time."),(0,n.yg)("h3",{id:"data-lake-acceleration"},"Data lake acceleration"),(0,n.yg)("h4",{id:"background-of-demand"},"Background of demand"),(0,n.yg)("p",null,"Many users have a need for federated data queries based on Doris. Doris's Multi Catalog feature makes this task very convenient. As long as a catalog is created, there is no need to migrate data to Doris, and external data can be queried through Doris"),(0,n.yg)("h4",{id:"pain-points"},"Pain points"),(0,n.yg)("p",null,"But this can also cause some problems, as the speed of querying external data may be affected by the network and third-party services, and may be slow. For scenarios with high response speed requirements, it is difficult to meet the requirements"),(0,n.yg)("h4",{id:"how-to-achieve-appearance-query-acceleration"},"How to achieve appearance query acceleration"),(0,n.yg)("p",null,"Asynchronous materialized views can be created based on external catalogs, but the data of the materialized view itself is stored within Doris, so querying the materialized view will be fast. Therefore, for scenarios with high response speed requirements, we can create a materialized view based on an external catalog"),(0,n.yg)("h3",{id:"data-modeling"},"Data modeling"),(0,n.yg)("p",null,"In some scenarios, users may use fact tables and dimension tables to create a summary table, which can then be used for Ad hoc queries. This summary table can also serve as a basic indicator table for subsequent modeling."),(0,n.yg)("p",null,"At this point, the materialized view can be used to model the data of the base table. Afterwards, the created materialized views can be used to create higher-level materialized views (supported by 2.1.3), flexibly meeting different needs."),(0,n.yg)("p",null,"Different levels of materialized views can have their own refresh methods set, for example:"),(0,n.yg)("ul",null,(0,n.yg)("li",{parentName:"ul"},"The first layer's materialized view can be set to timed refresh, while the second layer is set to trigger refresh. After the first layer's materialized view refresh is completed, it will automatically trigger the refresh of the second layer's materialized view."),(0,n.yg)("li",{parentName:"ul"},"The materialized views of each layer are set to be refreshed on a scheduled basis. Therefore, when the materialized views of the second layer are refreshed, it will not consider whether the materialized view data of the first layer is synchronized with the base table. Instead, the materialized view data of the first layer will be processed and synchronized to the second layer.")),(0,n.yg)("h2",{id:"the-relationship-between-materialized-views-and-olap"},"The relationship between materialized views and olap"),(0,n.yg)("p",null,"Note: Starting support in 2.1.4"),(0,n.yg)("p",null,"The underlying layer of the materialized view is an OLAP table of a duplicate model."),(0,n.yg)("p",null,"In theory, all functionalities of the Duplicate model are supported, but in order to efficiently refresh data in a materialized view, some limitations are placed on the functionalities:"),(0,n.yg)("ol",null,(0,n.yg)("li",{parentName:"ol"},"The partitioning of materialized views is automatically created and maintained based on the base table, so partitioning operations cannot be performed on materialized views"),(0,n.yg)("li",{parentName:"ol"},"Due to the related job processing behind the materialized view, the command to delete or rename the table cannot be used to manipulate the materialized view. Instead, the command of the materialized view itself needs to be used"),(0,n.yg)("li",{parentName:"ol"},"The column of the materialized view is derived from the query statement, so it cannot be modified, otherwise it will cause the refresh task of the materialized view to fail"),(0,n.yg)("li",{parentName:"ol"},"The materialized view has some properties that are not available in the duplicate table, which need to be modified through the commands in the materialized view. Other common properties need to be modified using the alter table"),(0,n.yg)("li",{parentName:"ol"},"Currently, it is not possible to create a Rollup for asynchronous materialized views, but indexes can be created"),(0,n.yg)("li",{parentName:"ol"},"The commands such as ",(0,n.yg)("inlineCode",{parentName:"li"},"desc")," and ",(0,n.yg)("inlineCode",{parentName:"li"},"show partitions")," are also applicable to materialized views")),(0,n.yg)("h2",{id:"the-use-of-materialized-views"},"The use of materialized views"),(0,n.yg)("p",null,"can be viewed ",(0,n.yg)("a",{parentName:"p",href:"/docs/query/view-materialized-view/query-async-materialized-view"},"Query async materialized view")),(0,n.yg)("h2",{id:"notice"},"Notice"),(0,n.yg)("ul",null,(0,n.yg)("li",{parentName:"ul"},"Asynchronous materialized views are only supported for use in the ",(0,n.yg)("a",{parentName:"li",href:"/docs/query/nereids/"},"Nereids optimizer")),(0,n.yg)("li",{parentName:"ul"},"Currently, determining the synchronization between materialized views and base tables is only supported for ",(0,n.yg)("inlineCode",{parentName:"li"},"OlapTable"),". For other types of external tables, they are directly considered to be synchronized. For instance, if the base tables of a materialized view are all external tables, they are assumed to be synchronized. When querying ",(0,n.yg)("inlineCode",{parentName:"li"},"mv_infos()"),", the SyncWithBaseTables flag will always return 1 (true) for these external tables. When refreshing a materialized view, it is necessary to manually refresh specific partitions or specify ",(0,n.yg)("inlineCode",{parentName:"li"},"complete")," to refresh all partitions.")))}u.isMDXComponent=!0}}]);