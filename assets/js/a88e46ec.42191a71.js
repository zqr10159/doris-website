"use strict";(self.webpackChunkdoris_website=self.webpackChunkdoris_website||[]).push([[736087],{15680:(e,t,n)=>{n.d(t,{xA:()=>d,yg:()=>y});var a=n(296540);function i(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function o(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);t&&(a=a.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,a)}return n}function r(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?o(Object(n),!0).forEach((function(t){i(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):o(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}function l(e,t){if(null==e)return{};var n,a,i=function(e,t){if(null==e)return{};var n,a,i={},o=Object.keys(e);for(a=0;a<o.length;a++)n=o[a],t.indexOf(n)>=0||(i[n]=e[n]);return i}(e,t);if(Object.getOwnPropertySymbols){var o=Object.getOwnPropertySymbols(e);for(a=0;a<o.length;a++)n=o[a],t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(i[n]=e[n])}return i}var s=a.createContext({}),p=function(e){var t=a.useContext(s),n=t;return e&&(n="function"==typeof e?e(t):r(r({},t),e)),n},d=function(e){var t=p(e.components);return a.createElement(s.Provider,{value:t},e.children)},m="mdxType",u={inlineCode:"code",wrapper:function(e){var t=e.children;return a.createElement(a.Fragment,{},t)}},c=a.forwardRef((function(e,t){var n=e.components,i=e.mdxType,o=e.originalType,s=e.parentName,d=l(e,["components","mdxType","originalType","parentName"]),m=p(n),c=i,y=m["".concat(s,".").concat(c)]||m[c]||u[c]||o;return n?a.createElement(y,r(r({ref:t},d),{},{components:n})):a.createElement(y,r({ref:t},d))}));function y(e,t){var n=arguments,i=t&&t.mdxType;if("string"==typeof e||i){var o=n.length,r=new Array(o);r[0]=c;var l={};for(var s in t)hasOwnProperty.call(t,s)&&(l[s]=t[s]);l.originalType=e,l[m]="string"==typeof e?e:i,r[1]=l;for(var p=2;p<o;p++)r[p]=n[p];return a.createElement.apply(null,r)}return a.createElement.apply(null,n)}c.displayName="MDXCreateElement"},745007:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>s,contentTitle:()=>r,default:()=>u,frontMatter:()=>o,metadata:()=>l,toc:()=>p});var a=n(58168),i=(n(296540),n(15680));const o={title:"Data Partitioning",language:"en"},r=void 0,l={unversionedId:"table-design/data-partition",id:"version-2.0/table-design/data-partition",title:"Data Partitioning",description:"\x3c!--",source:"@site/versioned_docs/version-2.0/table-design/data-partition.md",sourceDirName:"table-design",slug:"/table-design/data-partition",permalink:"/docs/2.0/table-design/data-partition",draft:!1,tags:[],version:"2.0",frontMatter:{title:"Data Partitioning",language:"en"},sidebar:"docs",previous:{title:"Usage Notes",permalink:"/docs/2.0/table-design/data-model/tips"},next:{title:"Schema Evolution",permalink:"/docs/2.0/table-design/schema-change"}},s={},p=[{value:"Basic concepts",id:"basic-concepts",level:2},{value:"Row &amp; Column",id:"row--column",level:3},{value:"Partition &amp; Tablet",id:"partition--tablet",level:3},{value:"Example of creating a table",id:"example-of-creating-a-table",level:3},{value:"View partition",id:"view-partition",level:3},{value:"Alter partition",id:"alter-partition",level:3},{value:"Manual partitioning",id:"manual-partitioning",level:2},{value:"Partition columns",id:"partition-columns",level:3},{value:"Range partition",id:"range-partition",level:3},{value:"List partition",id:"list-partition",level:3},{value:"Dynamic partition",id:"dynamic-partition",level:2},{value:"How to use",id:"how-to-use",level:3},{value:"Rule parameters",id:"rule-parameters",level:3},{value:"Create history partition rules",id:"create-history-partition-rules",level:4},{value:"Example",id:"example",level:3},{value:"Modify dynamic partition properties",id:"modify-dynamic-partition-properties",level:3},{value:"Check dynamic partition table scheduling status",id:"check-dynamic-partition-table-scheduling-status",level:3},{value:"Advanced operation",id:"advanced-operation",level:3},{value:"Auto partition",id:"auto-partition",level:2},{value:"Manual bucketing",id:"manual-bucketing",level:2},{value:"Recommendations for bucket number and data volume:",id:"recommendations-for-bucket-number-and-data-volume",level:3},{value:"Random distribution",id:"random-distribution",level:3},{value:"Auto bucket",id:"auto-bucket",level:2},{value:"Initial bucketing projection",id:"initial-bucketing-projection",level:3},{value:"Subsequent bucketing projection",id:"subsequent-bucketing-projection",level:3},{value:"Common Issues",id:"common-issues",level:2},{value:"More Help",id:"more-help",level:2}],d={toc:p},m="wrapper";function u(e){let{components:t,...n}=e;return(0,i.yg)(m,(0,a.A)({},d,n,{components:t,mdxType:"MDXLayout"}),(0,i.yg)("p",null,"This document mainly introduces table creation and data partitioning in Doris, as well as potential problems and solutions encountered during table creation operations."),(0,i.yg)("h2",{id:"basic-concepts"},"Basic concepts"),(0,i.yg)("p",null,"In Doris, data is logically described in the form of tables."),(0,i.yg)("h3",{id:"row--column"},"Row & Column"),(0,i.yg)("p",null,"A table consists of rows and columns:"),(0,i.yg)("ul",null,(0,i.yg)("li",{parentName:"ul"},"Row: Represents a single line of user data;"),(0,i.yg)("li",{parentName:"ul"},"Column: Used to describe different fields in a row of data;"),(0,i.yg)("li",{parentName:"ul"},"Columns can be divided into two types: Key and Value. From a business perspective, Key and Value can correspond to dimension columns and metric columns, respectively. The key columns in Doris are those specified in the table creation statement, which are the columns following the keywords ",(0,i.yg)("inlineCode",{parentName:"li"},"unique key"),", ",(0,i.yg)("inlineCode",{parentName:"li"},"aggregate key"),", or ",(0,i.yg)("inlineCode",{parentName:"li"},"duplicate key"),". The remaining columns are value columns. From the perspective of the aggregation model, rows with the same Key columns will be aggregated into a single row. The aggregation method for value columns is specified by the user during table creation. For more information on aggregation models, refer to the Doris ",(0,i.yg)("a",{parentName:"li",href:"../table-design/data-model/overview"},"Data Model"),".")),(0,i.yg)("h3",{id:"partition--tablet"},"Partition & Tablet"),(0,i.yg)("p",null,"Doris supports two levels of data partitioning. The first level is Partitioning, which supports Range and List partition. The second level is Bucket (also known as Tablet), which supports Hash and Random . If no partitioning is established during table creation, Doris generates a default partition that is transparent to the user. When using the default partition, only Bucket is supported."),(0,i.yg)("p",null,"In the Doris storage engine, data is horizontally partitioned into several tablets. Each tablet contains several rows of data. There is no overlap between the data in different tablets, and they are stored physically independently."),(0,i.yg)("p",null,"Multiple tablets logically belong to different partitions. A single tablet belongs to only one partition, while a partition contains several tablets. Because tablets are stored physically independently, partitions can also be considered physically independent. The tablet is the smallest physical storage unit for operations such as data movement and replication."),(0,i.yg)("p",null,"Several partitions compose a table. The partition can be considered the smallest logical management unit."),(0,i.yg)("p",null,"Benefits of Two-Level data partitioning:"),(0,i.yg)("ul",null,(0,i.yg)("li",{parentName:"ul"},"For dimensions with time or similar ordered values, such dimension columns can be used as partitioning columns. The partition granularity can be evaluated based on import frequency and partition data volume."),(0,i.yg)("li",{parentName:"ul"},"Historical data deletion requirements: If there is a need to delete historical data (such as retaining only the data for the most recent several days), composite partition can be used to achieve this goal by deleting historical partitions. Alternatively, DELETE statements can be sent within specified partitions to delete data."),(0,i.yg)("li",{parentName:"ul"},"Solving data skew issues: Each partition can specify the number of buckets independently. For example, when partitioning by day and there are significant differences in data volume between days, the number of buckets for each partition can be specified to reasonably distribute data across different partitions. It is recommended to choose a column with high distinctiveness as the bucketing column.")),(0,i.yg)("h3",{id:"example-of-creating-a-table"},"Example of creating a table"),(0,i.yg)("p",null,"CREATE TABLE in Doris is a synchronous command. It returns results after the SQL execution is completed. Successful returns indicate successful table creation. For more information, please refer to ",(0,i.yg)("a",{parentName:"p",href:"../sql-manual/sql-reference/Data-Definition-Statements/Create/CREATE-TABLE"},"CREATE TABLE"),", or input  the ",(0,i.yg)("inlineCode",{parentName:"p"},"HELP CREATE TABLE;")," command. "),(0,i.yg)("p",null,"This section introduces how to create tables in Doris by range partiton and hash buckets."),(0,i.yg)("pre",null,(0,i.yg)("code",{parentName:"pre"},'-- Range Partition\nCREATE TABLE IF NOT EXISTS example_range_tbl\n(\n     `user_id` LARGEINT NOT NULL COMMENT "User ID",\n    `date` DATE NOT NULL COMMENT "Date when the data are imported",\n    `timestamp` DATETIME NOT NULL COMMENT "Timestamp when the data are imported",\n    `city` VARCHAR(20) COMMENT "User location city",\n    `age` SMALLINT COMMENT "User age",\n    `sex` TINYINT COMMENT "User gender",\n    `last_visit_date` DATETIME REPLACE DEFAULT "1970-01-01 00:00:00" COMMENT "User last visit time",\n    `cost` BIGINT SUM DEFAULT "0" COMMENT "Total user consumption",\n    `max_dwell_time` INT MAX DEFAULT "0" COMMENT "Maximum user dwell time",\n    `min_dwell_time` INT MIN DEFAULT "99999" COMMENT "Minimum user dwell time"   \n)\nENGINE=OLAP\nAGGREGATE KEY(`user_id`, `date`, `timestamp`, `city`, `age`, `sex`)\nPARTITION BY RANGE(`date`)\n(\n    PARTITION `p201701` VALUES [("2017-01-01"),  ("2017-02-01")),\n    PARTITION `p201702` VALUES [("2017-02-01"), ("2017-03-01")),\n    PARTITION `p201703` VALUES [("2017-03-01"), ("2017-04-01"))\n)\nDISTRIBUTED BY HASH(`user_id`) BUCKETS 16\nPROPERTIES\n(\n    "replication_num" = "1"\n);\n')),(0,i.yg)("p",null,"Here use the AGGREGATE KEY data model as an example. In the AGGREGATE KEY data model, all columns that are specified with an aggregation type (SUM, REPLACE, MAX, or MIN) are Value columns. The rest are the Key columns."),(0,i.yg)("p",null,"In the PROPERTIES at the end of the CREATE TABLE statement, you can find detailed information about the relevant parameters that can be set in PROPERTIES by referring to the documentation on ",(0,i.yg)("a",{parentName:"p",href:"../sql-manual/sql-reference/Data-Definition-Statements/Create/CREATE-TABLE"},"CREATE TABLE"),"."),(0,i.yg)("p",null,"The default type of ENGINE is OLAP. In Doris, only this OLAP ENGINE type is responsible for data management and storage by Doris itself. Other ENGINE types, such as mysql, broker, es, etc., are essentially just mappings to tables in other external databases or systems, allowing Doris to read this data. However, Doris itself does not create, manage, or store any tables or data for non-OLAP ENGINE types."),(0,i.yg)("p",null,(0,i.yg)("inlineCode",{parentName:"p"},"IF NOT EXISTS")," indicates that if the table has not been created before, it will be created. Note that this only checks if the table name exists and does not check if the schema of the new table is the same as the schema of an existing table. Therefore, if there is a table with the same name but a different schema, this command will also return successfully, but it does not mean that a new table and a new schema have been created."),(0,i.yg)("h3",{id:"view-partition"},"View partition"),(0,i.yg)("p",null,"You can use the ",(0,i.yg)("inlineCode",{parentName:"p"},"show create table")," command to view the partition information of a table."),(0,i.yg)("pre",null,(0,i.yg)("code",{parentName:"pre"},"> show create table  example_range_tbl \n+-------------------+---------------------------------------------------------------------------------------------------------+                                                                                                            \n| Table             | Create Table                                                                                            |                                                                                                            \n+-------------------+---------------------------------------------------------------------------------------------------------+                                                                                                            \n| example_range_tbl | CREATE TABLE `example_range_tbl` (                                                                      |                                                                                                            \n|                   |   `user_id` largeint(40) NOT NULL COMMENT 'User ID',                                                     |                                                                                                            \n|                   |   `date` date NOT NULL COMMENT 'Date when the data are imported',                                                      |                                                                                                            \n|                   |   `timestamp` datetime NOT NULL COMMENT 'Timestamp when the data are imported',                                             |                                                                                                            \n|                   |   `city` varchar(20) NULL COMMENT 'User location city',                                                       |                                                                                                            \n|                   |   `age` smallint(6) NULL COMMENT 'User age',                                                            |                                                                                                            \n|                   |   `sex` tinyint(4) NULL COMMENT 'User gender',                                                             |                                                                                                            \n|                   |   `last_visit_date` datetime REPLACE NULL DEFAULT \"1970-01-01 00:00:00\" COMMENT 'User last visit time', |                                                                                                            \n|                   |   `cost` bigint(20) SUM NULL DEFAULT \"0\" COMMENT 'Total user consumption',                                          |                                                                                                            \n|                   |   `max_dwell_time` int(11) MAX NULL DEFAULT \"0\" COMMENT 'Maximum user dwell time',                             |                                                                                                            \n|                   |   `min_dwell_time` int(11) MIN NULL DEFAULT \"99999\" COMMENT 'Minimum user dwell time'                          |                                                                                                            \n|                   | ) ENGINE=OLAP                                                                                           |                                                                                                            \n|                   | AGGREGATE KEY(`user_id`, `date`, `timestamp`, `city`, `age`, `sex`)                                     |                                                                                                            \n|                   | COMMENT 'OLAP'                                                                                          |                                                                                                            \n|                   | PARTITION BY RANGE(`date`)                                                                              |                                                                                                            \n|                   | (PARTITION p201701 VALUES [('0000-01-01'), ('2017-02-01')),                                             |                                                                                                            \n|                   | PARTITION p201702 VALUES [('2017-02-01'), ('2017-03-01')),                                              |                                                                                                            \n|                   | PARTITION p201703 VALUES [('2017-03-01'), ('2017-04-01')))                                              |                                                                                                            \n|                   | DISTRIBUTED BY HASH(`user_id`) BUCKETS 16                                                               |                                                                                                            \n|                   | PROPERTIES (                                                                                            |                                                                                                            \n|                   | \"replication_allocation\" = \"tag.location.default: 1\",                                                   |                                                                                                            \n|                   | \"is_being_synced\" = \"false\",                                                                            |                                                                                                            \n|                   | \"storage_format\" = \"V2\",                                                                                |                                                                                                            \n|                   | \"light_schema_change\" = \"true\",                                                                         |                                                                                                            \n|                   | \"disable_auto_compaction\" = \"false\",                                                                    |                                                                                                            \n|                   | \"enable_single_replica_compaction\" = \"false\"                                                            |                                                                                                            \n|                   | );                                                                                                      |                                                                                                            \n+-------------------+---------------------------------------------------------------------------------------------------------+   \n")),(0,i.yg)("p",null,"You can use ",(0,i.yg)("inlineCode",{parentName:"p"},"show partitions from your_table")," command to view the partition information of a table."),(0,i.yg)("pre",null,(0,i.yg)("code",{parentName:"pre"},"> show partitions from example_range_tbl\n+-------------+---------------+----------------+---------------------+--------+--------------+--------------------------------------------------------------------------------+-----------------+---------+----------------+---------------\n+---------------------+---------------------+--------------------------+----------+------------+-------------------------+-----------+                                                                                                     \n| PartitionId | PartitionName | VisibleVersion | VisibleVersionTime  | State  | PartitionKey | Range                                                                          | DistributionKey | Buckets | ReplicationNum | StorageMedium \n| CooldownTime        | RemoteStoragePolicy | LastConsistencyCheckTime | DataSize | IsInMemory | ReplicaAllocation       | IsMutable |                                                                                                     \n+-------------+---------------+----------------+---------------------+--------+--------------+--------------------------------------------------------------------------------+-----------------+---------+----------------+---------------\n+---------------------+---------------------+--------------------------+----------+------------+-------------------------+-----------+                                                                                                     \n| 28731       | p201701       | 1              | 2024-01-25 10:50:51 | NORMAL | date         | [types: [DATEV2]; keys: [0000-01-01]; ..types: [DATEV2]; keys: [2017-02-01]; ) | user_id         | 16      | 1              | HDD           \n| 9999-12-31 23:59:59 |                     |                    | 0.000    | false      | tag.location.default: 1 | true      |                                                                                                     \n| 28732       | p201702       | 1              | 2024-01-25 10:50:51 | NORMAL | date         | [types: [DATEV2]; keys: [2017-02-01]; ..types: [DATEV2]; keys: [2017-03-01]; ) | user_id         | 16      | 1              | HDD           \n| 9999-12-31 23:59:59 |                     |                    | 0.000    | false      | tag.location.default: 1 | true      |                                                                                                     \n| 28733       | p201703       | 1              | 2024-01-25 10:50:51 | NORMAL | date         | [types: [DATEV2]; keys: [2017-03-01]; ..types: [DATEV2]; keys: [2017-04-01]; ) | user_id         | 16      | 1              | HDD           \n| 9999-12-31 23:59:59 |                     |                    | 0.000    | false      | tag.location.default: 1 | true      |                                                                                                     \n+-------------+---------------+----------------+---------------------+--------+--------------+--------------------------------------------------------------------------------+-----------------+---------+----------------+---------------\n+---------------------+---------------------+--------------------------+----------+------------+-------------------------+-----------+                  \n")),(0,i.yg)("h3",{id:"alter-partition"},"Alter partition"),(0,i.yg)("p",null,"You can add a new partition by using the ",(0,i.yg)("inlineCode",{parentName:"p"},"alter table add partition")," command."),(0,i.yg)("pre",null,(0,i.yg)("code",{parentName:"pre"},'ALTER TABLE example_range_tbl ADD  PARTITION p201704 VALUES LESS THAN("2020-05-01") DISTRIBUTED BY HASH(`user_id`) BUCKETS 5;\n')),(0,i.yg)("p",null,"For more partition modification operations, please refer to the SQL manual on ",(0,i.yg)("a",{parentName:"p",href:"../sql-manual/sql-reference/Data-Definition-Statements/Alter/ALTER-TABLE-PARTITION"},"ALTER-TABLE-PARTITION"),"."),(0,i.yg)("h2",{id:"manual-partitioning"},"Manual partitioning"),(0,i.yg)("h3",{id:"partition-columns"},"Partition columns"),(0,i.yg)("ul",null,(0,i.yg)("li",{parentName:"ul"},"Partition columns can be specified as one or multiple columns, and the partition columns must be KEY columns. The usage of multi-column partitioning will be introduced later in the summary section of multi-column partitioning."),(0,i.yg)("li",{parentName:"ul"},"When ",(0,i.yg)("inlineCode",{parentName:"li"},"allowPartitionColumnNullable")," is set to true, Range partition supports the use of NULL partition columns. List Partition does not support NULL partition columns at all times."),(0,i.yg)("li",{parentName:"ul"},"Regardless of the type of partition column, double quotes are required when writing partition values."),(0,i.yg)("li",{parentName:"ul"},"There is theoretically no upper limit on the number of partitions."),(0,i.yg)("li",{parentName:"ul"},"When creating a table without partitioning, the system will automatically generate a full-range partition with the same name as the table name. This partition is not visible to users and cannot be deleted or modified."),(0,i.yg)("li",{parentName:"ul"},"Overlapping ranges are not allowed when creating partitions.")),(0,i.yg)("h3",{id:"range-partition"},"Range partition"),(0,i.yg)("p",null,"Partition columns are usually time columns for convenient management of old and new data. Range partition supports column types such as DATE, DATETIME, TINYINT, SMALLINT, INT, BIGINT, and LARGEINT."),(0,i.yg)("p",null,"Partition information supports four writing methods:"),(0,i.yg)("ul",null,(0,i.yg)("li",{parentName:"ul"},"FIXED RANGE: the partition as a left-closed, right-open interval.")),(0,i.yg)("pre",null,(0,i.yg)("code",{parentName:"pre"},'PARTITION BY RANGE(col1[, col2, ...])                                                                                                                                                                                                  \n(                                                                                                                                                                                                                                      \n    PARTITION partition_name1 VALUES [("k1-lower1", "k2-lower1", "k3-lower1",...), ("k1-upper1", "k2-upper1", "k3-upper1", ...)),                                                                                                      \n    PARTITION partition_name2 VALUES [("k1-lower1-2", "k2-lower1-2", ...), ("k1-upper1-2", MAXVALUE, ))                                                                                                                                \n)                                                                                                                                                                                                                                      \n')),(0,i.yg)("p",null,"For example: "),(0,i.yg)("pre",null,(0,i.yg)("code",{parentName:"pre"},'PARTITION BY RANGE(`date`)\n(\n    PARTITION `p201701` VALUES [("2017-01-01"),  ("2017-02-01")),\n    PARTITION `p201702` VALUES [("2017-02-01"), ("2017-03-01")),\n    PARTITION `p201703` VALUES [("2017-03-01"), ("2017-04-01"))\n)\n')),(0,i.yg)("ul",null,(0,i.yg)("li",{parentName:"ul"},"LESS THAN: Only define the upper bound of the partition. The lower bound is determined by the upper bound of the previous partition.")),(0,i.yg)("pre",null,(0,i.yg)("code",{parentName:"pre"},'PARTITION BY RANGE(col1[, col2, ...])                                                                                                                                                                                                  \n(                                                                                                                                                                                                                                      \n    PARTITION partition_name1 VALUES LESS THAN MAXVALUE | ("value1", "value2", ...),                                                                                                                                                     \n    PARTITION partition_name2 VALUES LESS THAN MAXVALUE | ("value1", "value2", ...)                                                                                                                                                      \n)                                                                                                                                                                                                                                      \n')),(0,i.yg)("p",null,"For example:"),(0,i.yg)("pre",null,(0,i.yg)("code",{parentName:"pre"},'PARTITION BY RANGE(`date`)\n(\n    PARTITION `p201701` VALUES LESS THAN ("2017-02-01"),\n    PARTITION `p201702` VALUES LESS THAN ("2017-03-01"),\n    PARTITION `p201703` VALUES LESS THAN ("2017-04-01")\n)\n\nPARTITION BY RANGE(`date`)\n(\n    PARTITION `p201701` VALUES LESS THAN ("2017-02-01"),\n    PARTITION `p201702` VALUES LESS THAN ("2017-03-01"),\n    PARTITION `p201703` VALUES LESS THAN ("2017-04-01")\n    PARTITION `other` VALUES LESS THAN (MAXVALUE)\n)\n')),(0,i.yg)("ul",null,(0,i.yg)("li",{parentName:"ul"},"BATCH RANGE: Batch create RANGE partitions of numeric and time types, defining the partitions as left-closed, right-open intervals, and setting the step size.")),(0,i.yg)("pre",null,(0,i.yg)("code",{parentName:"pre"},'PARTITION BY RANGE(int_col)                                                                                                                                                                                                            \n(                                                                                                                                                                                                                                      \n    FROM (start_num) TO (end_num) INTERVAL interval_value                                                                                                                                                                                                   \n)\n\nPARTITION BY RANGE(date_col)                                                                                                                                                                                                            \n(                                                                                                                                                                                                                                      \n    FROM ("start_date") TO ("end_date") INTERVAL num YEAR | num MONTH | num WEEK | num DAY \uff5c 1 HOUR                                                                                                                                                                                                   \n)                                                                                                                                                                                                                                    \n')),(0,i.yg)("p",null,"For example: "),(0,i.yg)("pre",null,(0,i.yg)("code",{parentName:"pre"},'PARTITION BY RANGE(age)\n(\n    FROM (1) TO (100) INTERVAL 10\n)\n\nPARTITION BY RANGE(`date`)\n(\n    FROM ("2000-11-14") TO ("2021-11-14") INTERVAL 2 YEAR\n)\n')),(0,i.yg)("ul",null,(0,i.yg)("li",{parentName:"ul"},"MULTI RANGE: Batch create RANGE partitions, defining the partitions as left-closed, right-open intervals. For example:")),(0,i.yg)("pre",null,(0,i.yg)("code",{parentName:"pre"},'PARTITION BY RANGE(col)                                                                                                                                                                                                                \n(                                                                                                                                                                                                                                      \n   FROM ("2000-11-14") TO ("2021-11-14") INTERVAL 1 YEAR,                                                                                                                                                                              \n   FROM ("2021-11-14") TO ("2022-11-14") INTERVAL 1 MONTH,                                                                                                                                                                             \n   FROM ("2022-11-14") TO ("2023-01-03") INTERVAL 1 WEEK,                                                                                                                                                                              \n   FROM ("2023-01-03") TO ("2023-01-14") INTERVAL 1 DAY,\n   PARTITION p_20230114 VALUES [(\'2023-01-14\'), (\'2023-01-15\'))                                                                                                                                                                                \n)                                                                                                                                                                                                                                      \n')),(0,i.yg)("h3",{id:"list-partition"},"List partition"),(0,i.yg)("p",null,"Partition columns support data types such as BOOLEAN, TINYINT, SMALLINT, INT, BIGINT, LARGEINT, DATE, DATETIME, CHAR, and VARCHAR. Partition values are enumerated values. Only when the data is one of the enumerated values of the target partition, the partition can be hit ."),(0,i.yg)("p",null,"Partitions support specifying the enumerated values contained in each partition through VALUES IN (...)."),(0,i.yg)("p",null,"For example:"),(0,i.yg)("pre",null,(0,i.yg)("code",{parentName:"pre"},'PARTITION BY LIST(city)\n(\n    PARTITION `p_cn` VALUES IN ("Beijing", "Shanghai", "Hong Kong"),\n    PARTITION `p_usa` VALUES IN ("New York", "San Francisco"),\n    PARTITION `p_jp` VALUES IN ("Tokyo")\n)\n')),(0,i.yg)("p",null,"List partition also supports multi-column partitioning, for example:"),(0,i.yg)("pre",null,(0,i.yg)("code",{parentName:"pre"},'PARTITION BY LIST(id, city)\n(\n    PARTITION p1_city VALUES IN (("1", "Beijing"), ("1", "Shanghai")),\n    PARTITION p2_city VALUES IN (("2", "Beijing"), ("2", "Shanghai")),\n    PARTITION p3_city VALUES IN (("3", "Beijing"), ("3", "Shanghai"))\n)\n')),(0,i.yg)("h2",{id:"dynamic-partition"},"Dynamic partition"),(0,i.yg)("p",null,"Dynamic partition is designed to manage partition's Time-to-Life (TTL), reducing the burden on users."),(0,i.yg)("p",null,"In some usage scenarios, the user will partition the table according to the day and perform routine tasks regularly every day. At this time, the user needs to manually manage the partition. Otherwise, the data load may fail because the user does not create a partition. This brings additional maintenance costs to the user."),(0,i.yg)("p",null,"With dynamic partitioning, users can define rules for partition creation and deletion when establishing tables. The FE initiates a background thread to handle partition creation or deletion based on these user-defined rules. Users also have the flexibility to modify these rules during runtime."),(0,i.yg)("p",null,"It's important to note that dynamic partitioning is exclusively supported by range partitions. Currently, the functionality enables dynamic addition and deletion of partitions."),(0,i.yg)("admonition",{type:"tip"},(0,i.yg)("p",{parentName:"admonition"},"This feature will be disabled when synchronized by CCR. If this table is copied by CCR, that is, PROPERTIES contains ",(0,i.yg)("inlineCode",{parentName:"p"},"is_being_synced = true"),", it will be displayed as enabled in show create table, but will not actually take effect. When ",(0,i.yg)("inlineCode",{parentName:"p"},"is_being_synced")," is set to ",(0,i.yg)("inlineCode",{parentName:"p"},"false"),", these features will resume working, but the ",(0,i.yg)("inlineCode",{parentName:"p"},"is_being_synced")," property is for CCR peripheral modules only and should not be manually set during CCR synchronization.")),(0,i.yg)("h3",{id:"how-to-use"},"How to use"),(0,i.yg)("p",null,"The rules for dynamic partitioning can be specified when the table is created or modified at runtime."),(0,i.yg)("p",null,"Currently, dynamic partition rules can only be set for partition tables with single partition columns.    "),(0,i.yg)("ul",null,(0,i.yg)("li",{parentName:"ul"},"Specified when creating table")),(0,i.yg)("pre",null,(0,i.yg)("code",{parentName:"pre"},'CREATE TABLE tbl1\n(...)\nPROPERTIES\n(\n    "dynamic_partition.prop1" = "value1",\n    "dynamic_partition.prop2" = "value2",\n    ...\n)\n')),(0,i.yg)("ul",null,(0,i.yg)("li",{parentName:"ul"},"Modify at runtime")),(0,i.yg)("pre",null,(0,i.yg)("code",{parentName:"pre"},'ALTER TABLE tbl1 SET\n(\n    "dynamic_partition.prop1" = "value1",\n    "dynamic_partition.prop2" = "value2",\n    ...\n)\n')),(0,i.yg)("h3",{id:"rule-parameters"},"Rule parameters"),(0,i.yg)("p",null,"The rules of dynamic partition are prefixed with ",(0,i.yg)("inlineCode",{parentName:"p"},"dynamic_partition."),":"),(0,i.yg)("ul",null,(0,i.yg)("li",{parentName:"ul"},(0,i.yg)("p",{parentName:"li"},(0,i.yg)("inlineCode",{parentName:"p"},"dynamic_partition.enable")),(0,i.yg)("p",{parentName:"li"},"Whether to enable the dynamic partition feature. Can be specified as ",(0,i.yg)("inlineCode",{parentName:"p"},"TRUE")," or",(0,i.yg)("inlineCode",{parentName:"p"}," FALSE"),". If not filled, the default is ",(0,i.yg)("inlineCode",{parentName:"p"},"TRUE"),". If it is ",(0,i.yg)("inlineCode",{parentName:"p"},"FALSE"),", Doris will ignore the dynamic partitioning rules of the table.")),(0,i.yg)("li",{parentName:"ul"},(0,i.yg)("p",{parentName:"li"},(0,i.yg)("inlineCode",{parentName:"p"},"dynamic_partition.time_unit"),"(required parameters)"),(0,i.yg)("p",{parentName:"li"},"The unit for dynamic partition scheduling. Can be specified as ",(0,i.yg)("inlineCode",{parentName:"p"},"HOUR"),",",(0,i.yg)("inlineCode",{parentName:"p"},"DAY"),",",(0,i.yg)("inlineCode",{parentName:"p"}," WEEK"),", ",(0,i.yg)("inlineCode",{parentName:"p"},"MONTH")," and ",(0,i.yg)("inlineCode",{parentName:"p"},"YEAR"),", means to create or delete partitions by hour, day, week, month and year, respectively."),(0,i.yg)("p",{parentName:"li"},"When specified as ",(0,i.yg)("inlineCode",{parentName:"p"},"HOUR"),", the suffix format of the dynamically created partition name is ",(0,i.yg)("inlineCode",{parentName:"p"},"yyyyMMddHH"),", for example, ",(0,i.yg)("inlineCode",{parentName:"p"},"2020032501"),". ",(0,i.yg)("em",{parentName:"p"},"When the time unit is HOUR, the data type of partition column cannot be DATE.")),(0,i.yg)("p",{parentName:"li"},"When specified as ",(0,i.yg)("inlineCode",{parentName:"p"},"DAY"),", the suffix format of the dynamically created partition name is ",(0,i.yg)("inlineCode",{parentName:"p"},"yyyyMMdd"),", for example, ",(0,i.yg)("inlineCode",{parentName:"p"},"20200325"),"."),(0,i.yg)("p",{parentName:"li"},"When specified as ",(0,i.yg)("inlineCode",{parentName:"p"},"WEEK"),", the suffix format of the dynamically created partition name is ",(0,i.yg)("inlineCode",{parentName:"p"},"yyyy_ww"),". That is, the week of the year of current date. For example, the suffix of the partition created for ",(0,i.yg)("inlineCode",{parentName:"p"},"2020-03-25")," is ",(0,i.yg)("inlineCode",{parentName:"p"},"2020_13"),", indicating that it is currently the 13th week of 2020."),(0,i.yg)("p",{parentName:"li"},"When specified as ",(0,i.yg)("inlineCode",{parentName:"p"},"MONTH"),", the suffix format of the dynamically created partition name is ",(0,i.yg)("inlineCode",{parentName:"p"},"yyyyMM"),", for example, ",(0,i.yg)("inlineCode",{parentName:"p"},"202003"),"."),(0,i.yg)("p",{parentName:"li"},"When specified as ",(0,i.yg)("inlineCode",{parentName:"p"},"YEAR"),", the suffix format of the dynamically created partition name is ",(0,i.yg)("inlineCode",{parentName:"p"},"yyyy"),", for example, ",(0,i.yg)("inlineCode",{parentName:"p"},"2020"),".")),(0,i.yg)("li",{parentName:"ul"},(0,i.yg)("p",{parentName:"li"},(0,i.yg)("inlineCode",{parentName:"p"},"dynamic_partition.time_zone")),(0,i.yg)("p",{parentName:"li"},"The time zone of the dynamic partition, if not filled in, defaults to the time zone of the current machine's system, such as ",(0,i.yg)("inlineCode",{parentName:"p"},"Asia/Shanghai"),", if you want to know the supported TimeZone, you can found in ",(0,i.yg)("a",{parentName:"p",href:"https://en.wikipedia.org/wiki/List_of_tz_database_time_zones"},"Timezone"),".")),(0,i.yg)("li",{parentName:"ul"},(0,i.yg)("p",{parentName:"li"},(0,i.yg)("inlineCode",{parentName:"p"},"dynamic_partition.start")),(0,i.yg)("p",{parentName:"li"},"The starting offset of the dynamic partition, usually a negative number. Depending on the ",(0,i.yg)("inlineCode",{parentName:"p"},"time_unit")," attribute, based on the current day (week / month), the partitions with a partition range before this offset will be deleted. If not filled, the default is ",(0,i.yg)("inlineCode",{parentName:"p"},"-2147483648"),", that is, the history partition will not be  deleted.")),(0,i.yg)("li",{parentName:"ul"},(0,i.yg)("p",{parentName:"li"},(0,i.yg)("inlineCode",{parentName:"p"},"dynamic_partition.end"),"(required parameters)"),(0,i.yg)("p",{parentName:"li"},"The end offset of the dynamic partition, usually a positive number. According to the difference of the ",(0,i.yg)("inlineCode",{parentName:"p"},"time_unit")," attribute, the partition of the corresponding range is created in advance based on the current day (week / month)."))),(0,i.yg)("ul",null,(0,i.yg)("li",{parentName:"ul"},(0,i.yg)("p",{parentName:"li"},(0,i.yg)("inlineCode",{parentName:"p"},"dynamic_partition.prefix"),"(required parameters)"),(0,i.yg)("p",{parentName:"li"},"The dynamically created partition name prefix."))),(0,i.yg)("ul",null,(0,i.yg)("li",{parentName:"ul"},(0,i.yg)("inlineCode",{parentName:"li"},"dynamic_partition.buckets"))),(0,i.yg)("p",null,"\xa0\xa0\xa0\xa0The number of buckets corresponding to the dynamically created partitions."),(0,i.yg)("ul",null,(0,i.yg)("li",{parentName:"ul"},(0,i.yg)("p",{parentName:"li"},(0,i.yg)("inlineCode",{parentName:"p"},"dynamic_partition.replication_num")),(0,i.yg)("p",{parentName:"li"},"The replication number of dynamic partition.If not filled in, defaults to the number of table's replication number.\xa0\xa0\xa0\xa0")),(0,i.yg)("li",{parentName:"ul"},(0,i.yg)("p",{parentName:"li"},(0,i.yg)("inlineCode",{parentName:"p"},"dynamic_partition.start_day_of_week")),(0,i.yg)("p",{parentName:"li"},"When ",(0,i.yg)("inlineCode",{parentName:"p"},"time_unit")," is",(0,i.yg)("inlineCode",{parentName:"p"}," WEEK"),", this parameter is used to specify the starting point of the week. The value ranges from 1 to 7. Where 1 is Monday and 7 is Sunday. The default is 1, which means that every week starts on Monday.\xa0\xa0\xa0\xa0"))),(0,i.yg)("ul",null,(0,i.yg)("li",{parentName:"ul"},(0,i.yg)("p",{parentName:"li"},(0,i.yg)("inlineCode",{parentName:"p"},"dynamic_partition.start_day_of_month")),(0,i.yg)("p",{parentName:"li"},"When ",(0,i.yg)("inlineCode",{parentName:"p"},"time_unit")," is",(0,i.yg)("inlineCode",{parentName:"p"}," MONTH"),", this parameter is used to specify the start date of each month. The value ranges from 1 to 28. 1 means the 1st of every month, and 28 means the 28th of every month. The default is 1, which means that every month starts at 1st. The 29, 30 and 31 are not supported at the moment to avoid ambiguity caused by lunar years or months."))),(0,i.yg)("ul",null,(0,i.yg)("li",{parentName:"ul"},(0,i.yg)("p",{parentName:"li"},(0,i.yg)("inlineCode",{parentName:"p"},"dynamic_partition.create_history_partition")),(0,i.yg)("p",{parentName:"li"},"The default is false. When set to true, Doris will automatically create all partitions, as described in the creation rules below. At the same time, the parameter ",(0,i.yg)("inlineCode",{parentName:"p"},"max_dynamic_partition_num")," of FE will limit the total number of partitions to avoid creating too many partitions at once. When the number of partitions expected to be created is greater than ",(0,i.yg)("inlineCode",{parentName:"p"},"max_dynamic_partition_num"),", the operation will fail."),(0,i.yg)("p",{parentName:"li"},"When the ",(0,i.yg)("inlineCode",{parentName:"p"},"start")," attribute is not specified, this parameter has no effect.")),(0,i.yg)("li",{parentName:"ul"},(0,i.yg)("p",{parentName:"li"},(0,i.yg)("inlineCode",{parentName:"p"},"dynamic_partition.history_partition_num")),(0,i.yg)("p",{parentName:"li"},"When ",(0,i.yg)("inlineCode",{parentName:"p"},"create_history_partition")," is ",(0,i.yg)("inlineCode",{parentName:"p"},"true"),", this parameter is used to specify the number of history partitions. The default value is -1, which means it is not set.")),(0,i.yg)("li",{parentName:"ul"},(0,i.yg)("p",{parentName:"li"},(0,i.yg)("inlineCode",{parentName:"p"},"dynamic_partition.hot_partition_num")),(0,i.yg)("p",{parentName:"li"},"Specify how many of the latest partitions are hot partitions. For hot partition, the system will automatically set its ",(0,i.yg)("inlineCode",{parentName:"p"},"storage_medium")," parameter to SSD, and set ",(0,i.yg)("inlineCode",{parentName:"p"},"storage_cooldown_time"),"."),(0,i.yg)("admonition",{parentName:"li",type:"tip"},(0,i.yg)("p",{parentName:"admonition"},"If there is no SSD disk path under the storage path, configuring this parameter will cause dynamic partition creation to fail.")),(0,i.yg)("p",{parentName:"li"},(0,i.yg)("inlineCode",{parentName:"p"},"hot_partition_num")," is all partitions in the previous n days and in the future."),(0,i.yg)("p",{parentName:"li"},"Let us give an example. Suppose today is 2021-05-20, partition by day, and the properties of dynamic partition are set to: hot_partition_num=2, end=3, start=-3. Then the system will automatically create the following partitions, and set the ",(0,i.yg)("inlineCode",{parentName:"p"},"storage_medium")," and ",(0,i.yg)("inlineCode",{parentName:"p"},"storage_cooldown_time")," properties:"),(0,i.yg)("pre",{parentName:"li"},(0,i.yg)("code",{parentName:"pre"},'p20210517: ["2021-05-17", "2021-05-18") storage_medium=HDD storage_cooldown_time=9999-12-31 23:59:59\np20210518: ["2021-05-18", "2021-05-19") storage_medium=HDD storage_cooldown_time=9999-12-31 23:59:59\np20210519: ["2021-05-19", "2021-05-20") storage_medium=SSD storage_cooldown_time=2021-05-21 00:00:00\np20210520: ["2021-05-20", "2021-05-21") storage_medium=SSD storage_cooldown_time=2021-05-22 00:00:00\np20210521: ["2021-05-21", "2021-05-22") storage_medium=SSD storage_cooldown_time=2021-05-23 00:00:00\np20210522: ["2021-05-22", "2021-05-23") storage_medium=SSD storage_cooldown_time=2021-05-24 00:00:00\np20210523: ["2021-05-23", "2021-05-24") storage_medium=SSD storage_cooldown_time=2021-05-25 00:00:00\n')))),(0,i.yg)("ul",null,(0,i.yg)("li",{parentName:"ul"},(0,i.yg)("p",{parentName:"li"},(0,i.yg)("inlineCode",{parentName:"p"},"dynamic_partition.reserved_history_periods")),(0,i.yg)("p",{parentName:"li"},"The range of reserved history periods. It should be in the form of ",(0,i.yg)("inlineCode",{parentName:"p"},"[yyyy-MM-dd,yyyy-MM-dd],[...,...]")," while the ",(0,i.yg)("inlineCode",{parentName:"p"},"dynamic_partition.time_unit"),' is "DAY, WEEK, MONTH and YEAR". And it should be in the form of ',(0,i.yg)("inlineCode",{parentName:"p"},"[yyyy-MM-dd HH:mm:ss,yyyy-MM-dd HH:mm:ss],[...,...]")," while the dynamic_partition.time_unit",(0,i.yg)("inlineCode",{parentName:"p"},'is "HOUR". And no more spaces expected. The default value is'),'"NULL"`, which means it is not set.'),(0,i.yg)("p",{parentName:"li"},"Let us give an example. Suppose today is 2021-09-06, partitioned by day, and the properties of dynamic partition are set to: "),(0,i.yg)("p",{parentName:"li"},(0,i.yg)("inlineCode",{parentName:"p"},'time_unit="DAY/WEEK/MONTH/YEAR", end=3, start=-3, reserved_history_periods="[2020-06-01,2020-06-20],[2020-10-31,2020-11-15]"'),"."),(0,i.yg)("p",{parentName:"li"},"The system will automatically reserve following partitions in following period :"),(0,i.yg)("pre",{parentName:"li"},(0,i.yg)("code",{parentName:"pre"},'["2020-06-01","2020-06-20"],\n["2020-10-31","2020-11-15"]\n')),(0,i.yg)("p",{parentName:"li"},"or"),(0,i.yg)("p",{parentName:"li"},(0,i.yg)("inlineCode",{parentName:"p"},'time_unit="HOUR", end=3, start=-3, reserved_history_periods="[2020-06-01 00:00:00,2020-06-01 03:00:00]"'),"."),(0,i.yg)("p",{parentName:"li"},"The system will automatically reserve following partitions in following period :"),(0,i.yg)("pre",{parentName:"li"},(0,i.yg)("code",{parentName:"pre"},'["2020-06-01 00:00:00","2020-06-01 03:00:00"]\n')),(0,i.yg)("p",{parentName:"li"},"Otherwise, every ",(0,i.yg)("inlineCode",{parentName:"p"},"[...,...]")," in ",(0,i.yg)("inlineCode",{parentName:"p"},"reserved_history_periods")," is a couple of properties, and they should be set at the same time. And the first date can't be larger than the second one."))),(0,i.yg)("ul",null,(0,i.yg)("li",{parentName:"ul"},(0,i.yg)("p",{parentName:"li"},(0,i.yg)("inlineCode",{parentName:"p"},"dynamic_partition.storage_medium")),(0,i.yg)("version",{since:"1.2.3"}),(0,i.yg)("p",{parentName:"li"},"Specifies the default storage medium for the created dynamic partition. HDD is the default, SSD can be selected."),(0,i.yg)("p",{parentName:"li"},"Note that when set to SSD, the ",(0,i.yg)("inlineCode",{parentName:"p"},"hot_partition_num")," property will no longer take effect, all partitions will default to SSD storage media and the cooldown time will be 9999-12-31 23:59:59."))),(0,i.yg)("h4",{id:"create-history-partition-rules"},"Create history partition rules"),(0,i.yg)("p",null,"When ",(0,i.yg)("inlineCode",{parentName:"p"},"create_history_partition")," is ",(0,i.yg)("inlineCode",{parentName:"p"},"true"),", i.e. history partition creation is enabled, Doris determines the number of history partitions to be created based on ",(0,i.yg)("inlineCode",{parentName:"p"},"dynamic_partition.start")," and ",(0,i.yg)("inlineCode",{parentName:"p"},"dynamic_partition.history_partition_num"),". "),(0,i.yg)("p",null,"Assuming the number of history partitions to be created is ",(0,i.yg)("inlineCode",{parentName:"p"},"expect_create_partition_num"),", the number is as follows according to different settings."),(0,i.yg)("ul",null,(0,i.yg)("li",{parentName:"ul"},(0,i.yg)("inlineCode",{parentName:"li"},"create_history_partition")," = ",(0,i.yg)("inlineCode",{parentName:"li"},"true"),"  ",(0,i.yg)("ul",{parentName:"li"},(0,i.yg)("li",{parentName:"ul"},(0,i.yg)("inlineCode",{parentName:"li"},"dynamic_partition.history_partition_num")," is not set, i.e. -1.",(0,i.yg)("br",{parentName:"li"}),(0,i.yg)("inlineCode",{parentName:"li"},"expect_create_partition_num")," = ",(0,i.yg)("inlineCode",{parentName:"li"},"end")," - ",(0,i.yg)("inlineCode",{parentName:"li"},"start"),"; "),(0,i.yg)("li",{parentName:"ul"},(0,i.yg)("inlineCode",{parentName:"li"},"dynamic_partition.history_partition_num")," is set",(0,i.yg)("br",{parentName:"li"}),(0,i.yg)("inlineCode",{parentName:"li"},"expect_create_partition_num")," = ",(0,i.yg)("inlineCode",{parentName:"li"},"end")," - max(",(0,i.yg)("inlineCode",{parentName:"li"},"start"),", ",(0,i.yg)("inlineCode",{parentName:"li"},"-history_partition_num"),");"))),(0,i.yg)("li",{parentName:"ul"},(0,i.yg)("inlineCode",{parentName:"li"},"create_history_partition")," = ",(0,i.yg)("inlineCode",{parentName:"li"},"false"),"  ")),(0,i.yg)("p",null,"No history partition will be created, ",(0,i.yg)("inlineCode",{parentName:"p"},"expect_create_partition_num")," = ",(0,i.yg)("inlineCode",{parentName:"p"},"end")," - 0;"),(0,i.yg)("p",null,"When ",(0,i.yg)("inlineCode",{parentName:"p"},"expect_create_partition_num")," is greater than ",(0,i.yg)("inlineCode",{parentName:"p"},"max_dynamic_partition_num")," (default 500), creating too many partitions is prohibited."),(0,i.yg)("p",null,(0,i.yg)("strong",{parentName:"p"},"Examples:")," "),(0,i.yg)("p",null,"Suppose today is 2021-05-20, partition by day, and the attributes of dynamic partition are set to ",(0,i.yg)("inlineCode",{parentName:"p"},"create_history_partition=true, end=3, start=-3, history_partition_num=1"),", then the system will automatically create the following partitions."),(0,i.yg)("pre",null,(0,i.yg)("code",{parentName:"pre"},"p20210519\np20210520\np20210521\np20210522\np20210523\n")),(0,i.yg)("p",null,(0,i.yg)("inlineCode",{parentName:"p"},"history_partition_num=5")," and keep the rest attributes as in 1, then the system will automatically create the following partitions."),(0,i.yg)("pre",null,(0,i.yg)("code",{parentName:"pre"},"p20210517\np20210518\np20210519\np20210520\np20210521\np20210522\np20210523\n")),(0,i.yg)("p",null,(0,i.yg)("inlineCode",{parentName:"p"},"history_partition_num=-1")," i.e., if you do not set the number of history partitions and keep the rest of the attributes as in 1, the system will automatically create the following partitions."),(0,i.yg)("pre",null,(0,i.yg)("code",{parentName:"pre"},"p20210517\np20210518\np20210519\np20210520\np20210521\np20210522\np20210523\n")),(0,i.yg)("h3",{id:"example"},"Example"),(0,i.yg)("ol",null,(0,i.yg)("li",{parentName:"ol"},(0,i.yg)("p",{parentName:"li"},"Table ",(0,i.yg)("inlineCode",{parentName:"p"},"tbl1")," partition column k1, type is DATE, create a dynamic partition rule. By day partition, only the partitions of the last 7 days are kept, and the partitions of the next 3 days are created in advance."),(0,i.yg)("pre",{parentName:"li"},(0,i.yg)("code",{parentName:"pre"},'CREATE TABLE tbl1\n(\n    k1 DATE,\n    ...\n)\nPARTITION BY RANGE(k1) ()\nDISTRIBUTED BY HASH(k1)\nPROPERTIES\n(\n    "dynamic_partition.enable" = "true",\n    "dynamic_partition.time_unit" = "DAY",\n    "dynamic_partition.start" = "-7",\n    "dynamic_partition.end" = "3",\n    "dynamic_partition.prefix" = "p",\n    "dynamic_partition.buckets" = "32"\n);\n')),(0,i.yg)("p",{parentName:"li"},"Suppose the current date is 2020-05-29. According to the above rules, tbl1 will produce the following partitions:"),(0,i.yg)("pre",{parentName:"li"},(0,i.yg)("code",{parentName:"pre"},'p20200529: ["2020-05-29", "2020-05-30")\np20200530: ["2020-05-30", "2020-05-31")\np20200531: ["2020-05-31", "2020-06-01")\np20200601: ["2020-06-01", "2020-06-02")\n')),(0,i.yg)("p",{parentName:"li"},"On the next day, 2020-05-30, a new partition will be created ",(0,i.yg)("inlineCode",{parentName:"p"},'p20200602: [" 2020-06-02 "," 2020-06-03 ")')),(0,i.yg)("p",{parentName:"li"},"On 2020-06-06, because ",(0,i.yg)("inlineCode",{parentName:"p"},"dynamic_partition.start")," is set to 7, the partition 7 days ago will be deleted, that is, the partition ",(0,i.yg)("inlineCode",{parentName:"p"},"p20200529")," will be deleted.")),(0,i.yg)("li",{parentName:"ol"},(0,i.yg)("p",{parentName:"li"},"Table tbl1 partition column k1, type is DATETIME, create a dynamic partition rule. Partition by week, only keep the partition of the last 2 weeks, and create the partition of the next 2 weeks in advance."),(0,i.yg)("pre",{parentName:"li"},(0,i.yg)("code",{parentName:"pre"},'CREATE TABLE tbl1\n(\n    k1 DATETIME,\n    ...\n)\nPARTITION BY RANGE(k1) ()\nDISTRIBUTED BY HASH(k1)\nPROPERTIES\n(\n    "dynamic_partition.enable" = "true",\n    "dynamic_partition.time_unit" = "WEEK",\n    "dynamic_partition.start" = "-2",\n    "dynamic_partition.end" = "2",\n    "dynamic_partition.prefix" = "p",\n    "dynamic_partition.buckets" = "8"\n);\n')),(0,i.yg)("p",{parentName:"li"},"Suppose the current date is 2020-05-29, which is the 22nd week of 2020. The default week starts on Monday. Based on the above rules, tbl1 will produce the following partitions:"),(0,i.yg)("pre",{parentName:"li"},(0,i.yg)("code",{parentName:"pre"},'p2020_22: ["2020-05-25 00:00:00", "2020-06-01 00:00:00")\np2020_23: ["2020-06-01 00:00:00", "2020-06-08 00:00:00")\np2020_24: ["2020-06-08 00:00:00", "2020-06-15 00:00:00")\n')),(0,i.yg)("p",{parentName:"li"},"The start date of each partition is Monday of the week. At the same time, because the type of the partition column k1 is DATETIME, the partition value will fill the hour, minute and second fields, and all are 0."),(0,i.yg)("p",{parentName:"li"},"On 2020-06-15, the 25th week, the partition 2 weeks ago will be deleted, ie ",(0,i.yg)("inlineCode",{parentName:"p"},"p2020_22")," will be deleted."),(0,i.yg)("p",{parentName:"li"},"In the above example, suppose the user specified the start day of the week as ",(0,i.yg)("inlineCode",{parentName:"p"},'"dynamic_partition.start_day_of_week" = "3"'),", that is, set Wednesday as the start of week. The partition is as follows:"),(0,i.yg)("pre",{parentName:"li"},(0,i.yg)("code",{parentName:"pre"},'p2020_22: ["2020-05-27 00:00:00", "2020-06-03 00:00:00")\np2020_23: ["2020-06-03 00:00:00", "2020-06-10 00:00:00")\np2020_24: ["2020-06-10 00:00:00", "2020-06-17 00:00:00")\n')),(0,i.yg)("p",{parentName:"li"},"That is, the partition ranges from Wednesday of the current week to Tuesday of the next week."),(0,i.yg)("admonition",{parentName:"li",type:"tip"},(0,i.yg)("p",{parentName:"admonition"},"2019-12-31 and 2020-01-01 are in same week, if the starting date of the partition is 2019-12-31, the partition name is ",(0,i.yg)("inlineCode",{parentName:"p"},"p2019_53"),", if the starting date of the partition is 2020-01 -01, the partition name is ",(0,i.yg)("inlineCode",{parentName:"p"},"p2020_01"),"."))),(0,i.yg)("li",{parentName:"ol"},(0,i.yg)("p",{parentName:"li"},"Table tbl1 partition column k1, type is DATE, create a dynamic partition rule. Partition by month without deleting historical partitions, and create partitions for the next 2 months in advance. At the same time, set the starting date on the 3rd of each month."),(0,i.yg)("pre",{parentName:"li"},(0,i.yg)("code",{parentName:"pre"},'CREATE TABLE tbl1\n(\n    k1 DATE,\n    ...\n)\nPARTITION BY RANGE(k1) ()\nDISTRIBUTED BY HASH(k1)\nPROPERTIES\n(\n    "dynamic_partition.enable" = "true",\n    "dynamic_partition.time_unit" = "MONTH",\n    "dynamic_partition.end" = "2",\n    "dynamic_partition.prefix" = "p",\n    "dynamic_partition.buckets" = "8",\n    "dynamic_partition.start_day_of_month" = "3"\n);\n')),(0,i.yg)("p",{parentName:"li"},"Suppose the current date is 2020-05-29. Based on the above rules, tbl1 will produce the following partitions:"),(0,i.yg)("pre",{parentName:"li"},(0,i.yg)("code",{parentName:"pre"},'p202005: ["2020-05-03", "2020-06-03")\np202006: ["2020-06-03", "2020-07-03")\np202007: ["2020-07-03", "2020-08-03")\n')),(0,i.yg)("p",{parentName:"li"},"Because ",(0,i.yg)("inlineCode",{parentName:"p"},"dynamic_partition.start")," is not set, the historical partition will not be deleted."),(0,i.yg)("p",{parentName:"li"},"Assuming that today is 2020-05-20, and set 28th as the start of each month, the partition range is:"),(0,i.yg)("pre",{parentName:"li"},(0,i.yg)("code",{parentName:"pre"},'p202004: ["2020-04-28", "2020-05-28")\np202005: ["2020-05-28", "2020-06-28")\np202006: ["2020-06-28", "2020-07-28")\n')))),(0,i.yg)("h3",{id:"modify-dynamic-partition-properties"},"Modify dynamic partition properties"),(0,i.yg)("p",null,"You can modify the properties of the dynamic partition with the following command"),(0,i.yg)("pre",null,(0,i.yg)("code",{parentName:"pre"},'ALTER TABLE tbl1 SET\n(\n    "dynamic_partition.prop1" = "value1",\n    ...\n);\n')),(0,i.yg)("p",null,"The modification of certain attributes may cause conflicts. Assume that the partition granularity was DAY and the following partitions have been created:"),(0,i.yg)("pre",null,(0,i.yg)("code",{parentName:"pre"},'p20200519: ["2020-05-19", "2020-05-20")\np20200520: ["2020-05-20", "2020-05-21")\np20200521: ["2020-05-21", "2020-05-22")\n')),(0,i.yg)("p",null,"If the partition granularity is changed to MONTH at this time, the system will try to create a partition with the range ",(0,i.yg)("inlineCode",{parentName:"p"},'["2020-05-01", "2020-06-01")'),", and this range conflicts with the existing partition. So it cannot be created. And the partition with the range ",(0,i.yg)("inlineCode",{parentName:"p"},'["2020-06-01", "2020-07-01")')," can be created normally. Therefore, the partition between 2020-05-22 and 2020-05-30 needs to be filled manually."),(0,i.yg)("h3",{id:"check-dynamic-partition-table-scheduling-status"},"Check dynamic partition table scheduling status"),(0,i.yg)("p",null,"You can further view the scheduling of dynamic partitioned tables by using the following command:"),(0,i.yg)("pre",null,(0,i.yg)("code",{parentName:"pre"},"mysql> SHOW DYNAMIC PARTITION TABLES;\n+-----------+--------+----------+-------------+------+--------+---------+-----------+----------------+---------------------+--------+------------------------+----------------------+-------------------------+\n| TableName | Enable | TimeUnit | Start       | End  | Prefix | Buckets | StartOf   | LastUpdateTime | LastSchedulerTime   | State  | LastCreatePartitionMsg | LastDropPartitionMsg | ReservedHistoryPeriods  |\n+-----------+--------+----------+-------------+------+--------+---------+-----------+----------------+---------------------+--------+------------------------+----------------------+-------------------------+\n| d3        | true   | WEEK     | -3          | 3    | p      | 1       | MONDAY    | N/A            | 2020-05-25 14:29:24 | NORMAL | N/A                    | N/A                  | [2021-12-01,2021-12-31] |\n| d5        | true   | DAY      | -7          | 3    | p      | 32      | N/A       | N/A            | 2020-05-25 14:29:24 | NORMAL | N/A                    | N/A                  | NULL                    |\n| d4        | true   | WEEK     | -3          | 3    | p      | 1       | WEDNESDAY | N/A            | 2020-05-25 14:29:24 | NORMAL | N/A                    | N/A                  | NULL                    |\n| d6        | true   | MONTH    | -2147483648 | 2    | p      | 8       | 3rd       | N/A            | 2020-05-25 14:29:24 | NORMAL | N/A                    | N/A                  | NULL                    |\n| d2        | true   | DAY      | -3          | 3    | p      | 32      | N/A       | N/A            | 2020-05-25 14:29:24 | NORMAL | N/A                    | N/A                  | NULL                    |\n| d7        | true   | MONTH    | -2147483648 | 5    | p      | 8       | 24th      | N/A            | 2020-05-25 14:29:24 | NORMAL | N/A                    | N/A                  | NULL                    |\n+-----------+--------+----------+-------------+------+--------+---------+-----------+----------------+---------------------+--------+------------------------+----------------------+-------------------------+\n7 rows in set (0.02 sec)\n")),(0,i.yg)("ul",null,(0,i.yg)("li",{parentName:"ul"},"LastUpdateTime: The last time of modifying dynamic partition properties "),(0,i.yg)("li",{parentName:"ul"},"LastSchedulerTime: The last time of performing dynamic partition scheduling"),(0,i.yg)("li",{parentName:"ul"},"State: The state of the last execution of dynamic partition scheduling"),(0,i.yg)("li",{parentName:"ul"},"LastCreatePartitionMsg: Error message of the last time to dynamically add partition scheduling"),(0,i.yg)("li",{parentName:"ul"},"LastDropPartitionMsg: Error message of the last execution of dynamic deletion partition scheduling")),(0,i.yg)("h3",{id:"advanced-operation"},"Advanced operation"),(0,i.yg)("p",null,(0,i.yg)("strong",{parentName:"p"},"FE Configuration Item")),(0,i.yg)("ul",null,(0,i.yg)("li",{parentName:"ul"},(0,i.yg)("p",{parentName:"li"},"dynamic","_","partition","_","enable"),(0,i.yg)("p",{parentName:"li"},"Whether to enable Doris's dynamic partition feature. The default value is false, which is off. This parameter only affects the partitioning operation of dynamic partition tables, not normal tables. You can modify the parameters in ",(0,i.yg)("inlineCode",{parentName:"p"},"fe.conf")," and restart FE to take effect. You can also execute the following commands at runtime to take effect:"),(0,i.yg)("pre",{parentName:"li"},(0,i.yg)("code",{parentName:"pre"},'MySQL protocol:\n\n`ADMIN SET FRONTEND CONFIG ("dynamic_partition_enable" = "true")`\n\nHTTP protocol:\n\n`curl --location-trusted -u username:password -XGET http://fe_host:fe_http_port/api/_set_config?dynamic_partition_enable=true`\n')),(0,i.yg)("p",{parentName:"li"},"To turn off dynamic partitioning globally, set this parameter to false.")),(0,i.yg)("li",{parentName:"ul"},(0,i.yg)("p",{parentName:"li"},"dynamic","_","partition","_","check","_","interval","_","seconds"),(0,i.yg)("p",{parentName:"li"},"The execution frequency of dynamic partition threads defaults to 3600 (1 hour), that is, scheduling is performed every 1 hour. You can modify the parameters in ",(0,i.yg)("inlineCode",{parentName:"p"},"fe.conf")," and restart FE to take effect. You can also modify the following commands at runtime:"),(0,i.yg)("pre",{parentName:"li"},(0,i.yg)("code",{parentName:"pre"},'MySQL protocol:\n\n`ADMIN SET FRONTEND CONFIG ("dynamic_partition_check_interval_seconds" = "7200")`\n\nHTTP protocol:\n\n`curl --location-trusted -u username:password -XGET http://fe_host:fe_http_port/api/_set_config?dynamic_partition_check_interval_seconds=432000`\n')))),(0,i.yg)("p",null,(0,i.yg)("strong",{parentName:"p"},"Converting dynamic and manual partition tables to each other")),(0,i.yg)("p",null,"For a table, dynamic and manual partitioning can be freely converted, but they cannot exist at the same time, there is and only one state."),(0,i.yg)("p",null,(0,i.yg)("strong",{parentName:"p"},"Converting Manual Partitioning to Dynamic Partitioning")),(0,i.yg)("p",null,"If a table is not dynamically partitioned when it is created, it can be converted to dynamic partitioning at runtime by modifying the dynamic partitioning properties with ",(0,i.yg)("inlineCode",{parentName:"p"},"ALTER TABLE"),", an example of which can be seen with ",(0,i.yg)("inlineCode",{parentName:"p"},"HELP ALTER TABLE"),"."),(0,i.yg)("p",null,"When dynamic partitioning feature is enabled, Doris will no longer allow users to manage partitions manually, but will automatically manage partitions based on dynamic partition properties."),(0,i.yg)("admonition",{type:"tip"},(0,i.yg)("p",{parentName:"admonition"},"If ",(0,i.yg)("inlineCode",{parentName:"p"},"dynamic_partition.start")," is set, historical partitions with a partition range before the start offset of the dynamic partition will be deleted.")),(0,i.yg)("p",null,(0,i.yg)("strong",{parentName:"p"},"Converting Dynamic Partitioning to Manual Partitioning")),(0,i.yg)("p",null,"The dynamic partitioning feature can be disabled by executing ",(0,i.yg)("inlineCode",{parentName:"p"},'ALTER TABLE tbl_name SET ("dynamic_partition.enable" = "false") ')," and converting it to a manual partition table."),(0,i.yg)("p",null,"When dynamic partitioning feature is disabled, Doris will no longer manage partitions automatically, and users will have to create or delete partitions manually by using ",(0,i.yg)("inlineCode",{parentName:"p"},"ALTER TABLE"),"."),(0,i.yg)("h2",{id:"auto-partition"},"Auto partition"),(0,i.yg)("admonition",{type:"tip"},(0,i.yg)("p",{parentName:"admonition"},"Doris version 2.1 starts to support automatic partitioning. To use this feature, please ",(0,i.yg)("a",{parentName:"p",href:"https://doris.apache.org/zh-CN/download"},"download Doris 2.1")," and refer to the documentation for version 2.1.")),(0,i.yg)("p",null,"The Auto Partitioning feature supports automatic detection of whether the corresponding partition exists during the data import process. If it does not exist, the partition will be created automatically and imported normally."),(0,i.yg)("p",null,"The auto partition function mainly solves the problem that the user expects to partition the table based on a certain column, but the data distribution of the column is scattered or unpredictable, so it is difficult to accurately create the required partitions when building or adjusting the structure of the table, or the number of partitions is so large that it is too cumbersome to create them manually."),(0,i.yg)("p",null,"Take the time type partition column as an example, in the Dynamic Partition function, we support the automatic creation of new partitions to accommodate real-time data at specific time periods. For real-time user behavior logs and other scenarios, this feature basically meets the requirements. However, in more complex scenarios, such as dealing with non-real-time data, the partition column is independent of the current system time and contains a large number of discrete values. At this time to improve efficiency we want to partition the data based on this column, but the data may actually involve the partition can not be grasped in advance, or the expected number of required partitions is too large. In this case, dynamic partitioning or manually created partitions can not meet our needs, automatic partitioning function is very good to cover such needs."),(0,i.yg)("p",null,"Suppose our table DDL is as follows:"),(0,i.yg)("pre",null,(0,i.yg)("code",{parentName:"pre",className:"language-sql"},"CREATE TABLE `DAILY_TRADE_VALUE`\n(\n    `TRADE_DATE`              datev2 NOT NULL COMMENT 'TRADE_DATE',\n    `TRADE_ID`                varchar(40) NOT NULL COMMENT 'TRADE_ID',\n    ......\n)\nUNIQUE KEY(`TRADE_DATE`, `TRADE_ID`)\nPARTITION BY RANGE(`TRADE_DATE`)\n(\n    PARTITION p_2000 VALUES [('2000-01-01'), ('2001-01-01')),\n    PARTITION p_2001 VALUES [('2001-01-01'), ('2002-01-01')),\n    PARTITION p_2002 VALUES [('2002-01-01'), ('2003-01-01')),\n    PARTITION p_2003 VALUES [('2003-01-01'), ('2004-01-01')),\n    PARTITION p_2004 VALUES [('2004-01-01'), ('2005-01-01')),\n    PARTITION p_2005 VALUES [('2005-01-01'), ('2006-01-01')),\n    PARTITION p_2006 VALUES [('2006-01-01'), ('2007-01-01')),\n    PARTITION p_2007 VALUES [('2007-01-01'), ('2008-01-01')),\n    PARTITION p_2008 VALUES [('2008-01-01'), ('2009-01-01')),\n    PARTITION p_2009 VALUES [('2009-01-01'), ('2010-01-01')),\n    PARTITION p_2010 VALUES [('2010-01-01'), ('2011-01-01')),\n    PARTITION p_2011 VALUES [('2011-01-01'), ('2012-01-01')),\n    PARTITION p_2012 VALUES [('2012-01-01'), ('2013-01-01')),\n    PARTITION p_2013 VALUES [('2013-01-01'), ('2014-01-01')),\n    PARTITION p_2014 VALUES [('2014-01-01'), ('2015-01-01')),\n    PARTITION p_2015 VALUES [('2015-01-01'), ('2016-01-01')),\n    PARTITION p_2016 VALUES [('2016-01-01'), ('2017-01-01')),\n    PARTITION p_2017 VALUES [('2017-01-01'), ('2018-01-01')),\n    PARTITION p_2018 VALUES [('2018-01-01'), ('2019-01-01')),\n    PARTITION p_2019 VALUES [('2019-01-01'), ('2020-01-01')),\n    PARTITION p_2020 VALUES [('2020-01-01'), ('2021-01-01')),\n    PARTITION p_2021 VALUES [('2021-01-01'), ('2022-01-01'))\n)\nDISTRIBUTED BY HASH(`TRADE_DATE`) BUCKETS 10\nPROPERTIES (\n  \"replication_num\" = \"1\"\n);\n")),(0,i.yg)("p",null,"The table stores a large amount of business history data, partitioned based on the date the transaction occurred. As you can see when building the table, we need to manually create the partitions in advance. If the data range of the partitioned columns changes, for example, 2022 is added to the above table, we need to create a partition by ",(0,i.yg)("a",{parentName:"p",href:"../../sql-manual/sql-reference/Data-Definition-Statements/Alter/ALTER-TABLE-PARTITION"},"ALTER-TABLE-PARTITION")," to make changes to the table partition. If such partitions need to be changed, or subdivided at a finer level of granularity, it is very tedious to modify them. At this point we can rewrite the table DDL using AUTO PARTITION."),(0,i.yg)("h2",{id:"manual-bucketing"},"Manual bucketing"),(0,i.yg)("p",null,"If partitions are used, ",(0,i.yg)("inlineCode",{parentName:"p"},"DISTRIBUTED .."),". statement describes the rules for dividing data within each partition."),(0,i.yg)("p",null,"If partitions are not used, it describes the rules for dividing the data across the entire table."),(0,i.yg)("p",null,"It is also possible to specify a bucketing method for each partition individually."),(0,i.yg)("p",null,"The bucket columns can be multiple columns. For the Aggregate and Unique models, they must be Key columns, while for the duplicate key data model, they can be both key and value columns. Bucket columns can be the same as or different from Partition columns."),(0,i.yg)("p",null,"The choice of bucket columns involves a trade-off between query throughput and query concurrency:"),(0,i.yg)("ul",null,(0,i.yg)("li",{parentName:"ul"},"If multiple bucket columns are selected, the data distribution will be more uniform. If a query condition does not include equal conditions for all bucket columns, the query will trigger simultaneous scanning of all buckets, increasing query throughput and reducing the latency of individual queries. This approach is suitable for high-throughput, low-concurrency query scenarios."),(0,i.yg)("li",{parentName:"ul"},"If only one or a few bucket columns are selected, a point query can trigger scanning of just one bucket. In this case, when multiple point queries are concurrent, there is a higher probability that they will trigger scanning of different buckets, reducing the IO impact between queries (especially when different buckets are distributed across different disks). Therefore, this approach is suitable for high-concurrency point query scenarios.")),(0,i.yg)("h3",{id:"recommendations-for-bucket-number-and-data-volume"},"Recommendations for bucket number and data volume:"),(0,i.yg)("ul",null,(0,i.yg)("li",{parentName:"ul"},"The total number of tablets for a table is equal to (Partition num * Bucket num)."),(0,i.yg)("li",{parentName:"ul"},"Without considering expansion, it is recommended that the number of tablets for a table be slightly more than the total number of disks in the cluster."),(0,i.yg)("li",{parentName:"ul"},"In theory, there is no upper or lower limit for the data volume of a single tablet, but it is recommended to be within the range of 1G - 10G. If the data volume of a single tablet is too small, the data aggregation effect will not be good, and the metadata management pressure will be high. If the data volume is too large, it will not be conducive to the migration and replenishment of replicas, and it will increase the cost of retrying failed operations such as Schema Change or Rollup (the granularity of retrying these operations is the tablet)."),(0,i.yg)("li",{parentName:"ul"},"When there is a conflict between the data volume principle and the quantity principle of tablets, it is recommended to prioritize the data volume principle."),(0,i.yg)("li",{parentName:"ul"},"When creating a table, the bucket number for each partition is uniformly specified. However, when dynamically adding partitions ",(0,i.yg)("inlineCode",{parentName:"li"},"ADD PARTITION"),", the bucket number for the new partition can be specified separately. This feature can be conveniently used to handle data reduction or expansion."),(0,i.yg)("li",{parentName:"ul"},"Once the bucket number for a partition is specified, it cannot be changed. Therefore, when determining the bucket number, it is necessary to consider the cluster expansion scenario in advance. For example, if there are only 3 hosts with 1 disk each, and the bucket number is set to 3 or less, then even if more machines are added later, the concurrency cannot be improved.")),(0,i.yg)("p",null,"Here are some examples: Assuming there are 10 BEs, each with one disk. If a table has a total size of 500MB, 4-8 tablets can be considered. For 5GB: 8-16 tablets. For 50GB: 32 tablets. For 500GB: It is recommended to partition the table, with each partition size around 50GB and 16-32 tablets per partition. For 5TB: It is recommended to partition the table, with each partition size around 50GB and 16-32 tablets per partition."),(0,i.yg)("p",null,"The data volume of a table can be viewed using the ",(0,i.yg)("a",{parentName:"p",href:"../sql-manual/sql-reference/Show-Statements/SHOW-DATA"},"SHOW DATA")," command, and the result should be divided by the number of replicas to obtain the actual data volume of the table."),(0,i.yg)("h3",{id:"random-distribution"},"Random distribution"),(0,i.yg)("ul",null,(0,i.yg)("li",{parentName:"ul"},"If an OLAP table does not have fields of the update type, setting the data bucketing mode of the table to RANDOM can avoid severe data skew. When data is imported into the corresponding partitions of the table, each batch of a single import job will randomly select a tablet for writing."),(0,i.yg)("li",{parentName:"ul"},"When the bucketing mode of a table is set to RANDOM, there is no bucketing column, it is not possible to query only a few buckets based on the values of the bucketing column. Queries on the table will simultaneously scan all buckets that hit the partition. This setting is suitable for aggregate query analysis of the entire table data, but not suitable for high-concurrency point queries."),(0,i.yg)("li",{parentName:"ul"},"If the data distribution of the OLAP table is Random Distribution, then during data import, single-tablet import mode can be set (set ",(0,i.yg)("inlineCode",{parentName:"li"},"load_to_single_tablet")," to true). Then, during large-volume data import, a task will only write to one tablet when writing data to the corresponding partition. This can improve the concurrency and throughput of data import, reduce the write amplification caused by data import and compaction, and ensure the stability of the cluster.")),(0,i.yg)("h2",{id:"auto-bucket"},"Auto bucket"),(0,i.yg)("p",null,"Users often encounter various issues due to improper bucket settings. To address this, we provide an automated approach for setting the number of buckets, which is currently applicable only to OLAP tables."),(0,i.yg)("admonition",{type:"tip"},(0,i.yg)("p",{parentName:"admonition"},"This feature will be disabled when synchronized by CCR. If this table is copied by CCR, that is, PROPERTIES contains ",(0,i.yg)("inlineCode",{parentName:"p"},"is_being_synced = true"),", it will be displayed as enabled in show create table, but will not actually take effect. When ",(0,i.yg)("inlineCode",{parentName:"p"},"is_being_synced")," is set to ",(0,i.yg)("inlineCode",{parentName:"p"},"false"),", these features will resume working, but the ",(0,i.yg)("inlineCode",{parentName:"p"},"is_being_synced")," property is for CCR peripheral modules only and should not be manually set during CCR synchronization.  ")),(0,i.yg)("p",null,"In the past, user had to set the number of buckets manually when creating table, but the automatic bucket feature is a way for Apache Doris to dynamically project the number of buckets, so that the number of buckets always stays within a suitable range and users don't have to worry about the minutiae of the number of buckets."),(0,i.yg)("p",null,"For the sake of clarity, this section splits the bucket into two periods, the initial bucket and the subsequent bucket; the initial and subsequent are just terms used in this article to describe the feature clearly, there is no initial or subsequent Apache Doris bucket."),(0,i.yg)("p",null,"As we know from the section above on creating buckets, ",(0,i.yg)("inlineCode",{parentName:"p"},"BUCKET_DESC")," is very simple, but you need to specify the number of buckets; for the automatic bucket projection feature, the syntax of BUCKET_DESC directly changes the number of buckets to ",(0,i.yg)("inlineCode",{parentName:"p"},"Auto")," and adds a new Properties configuration."),(0,i.yg)("pre",null,(0,i.yg)("code",{parentName:"pre",className:"language-sql"},'-- old version of the creation syntax for specifying the number of buckets\nDISTRIBUTED BY HASH(site) BUCKETS 20\n\n-- Newer versions use the creation syntax for automatic bucket imputation\nDISTRIBUTED BY HASH(site) BUCKETS AUTO\nproperties("estimate_partition_size" = "100G")\n')),(0,i.yg)("p",null,"The new configuration parameter estimate_partition_size indicates the amount of data for a single partition. This parameter is optional and if not given, Doris will take the default value of estimate_partition_size to 10GB."),(0,i.yg)("p",null,"As you know from the above, a partitioned bucket is a Tablet at the physical level, and for best performance, it is recommended that the Tablet size be in the range of 1GB - 10GB. So how does the automatic bucketing projection ensure that the Tablet size is within this range? "),(0,i.yg)("p",null,"To summarize, there are a few principles."),(0,i.yg)("ul",null,(0,i.yg)("li",{parentName:"ul"},"If the overall data volume is small, the number of buckets should not be set too high"),(0,i.yg)("li",{parentName:"ul"},"If the overall data volume is large, the number of buckets should be related to the total number of disk blocks, so as to fully utilize the capacity of each BE machine and each disk")),(0,i.yg)("admonition",{type:"tip"},(0,i.yg)("p",{parentName:"admonition"},"propertie estimate_partition_size not support alter")),(0,i.yg)("h3",{id:"initial-bucketing-projection"},"Initial bucketing projection"),(0,i.yg)("ol",null,(0,i.yg)("li",{parentName:"ol"},"Obtain a number of buckets N based on the data size. Initially, we divide the value of ",(0,i.yg)("inlineCode",{parentName:"li"},"estimate_partition_size")," by 5 (considering a data compression ratio of 5 to 1 when storing data in text format in Doris). The result obtained is")),(0,i.yg)("pre",null,(0,i.yg)("code",{parentName:"pre"},"(, 100MB), then take N=1\n\n[100MB, 1GB), then take N=2\n\n(1GB, ), then one bucket per GB\n")),(0,i.yg)("ol",{start:2},(0,i.yg)("li",{parentName:"ol"},"calculate the number of buckets M based on the number of BE nodes and the disk capacity of each BE node.")),(0,i.yg)("pre",null,(0,i.yg)("code",{parentName:"pre"},"Where each BE node counts as 1, and every 50G of disk capacity counts as 1.\n\nThe calculation rule for M is: M = Number of BE nodes * (Size of one disk block / 50GB) * Number of disk blocks.\n\nFor example: If there are 3 BEs, and each BE has 4 disks of 500GB, then M = 3 * (500GB / 50GB) * 4 = 120.\n\n")),(0,i.yg)("ol",{start:3},(0,i.yg)("li",{parentName:"ol"},"Calculation logic to get the final number of buckets.")),(0,i.yg)("pre",null,(0,i.yg)("code",{parentName:"pre"},"Calculate an intermediate value x = min(M, N, 128).\n\nIf x < N and x < the number of BE nodes, the final bucket is y.\n\nThe number of BE nodes; otherwise, the final bucket is x.\n")),(0,i.yg)("ol",{start:4},(0,i.yg)("li",{parentName:"ol"},"x = max(x, autobucket_min_buckets), Here autobucket_min_buckets is configured in Config (where, default is 1)")),(0,i.yg)("p",null,"The pseudo-code representation of the above process is as follows"),(0,i.yg)("pre",null,(0,i.yg)("code",{parentName:"pre"},"int N = Compute the N value;\nint M = compute M value;\n\nint y = number of BE nodes;\nint x = min(M, N, 128);\n\nif (x < N && x < y) {\n  return y;\n}\nreturn x;\n")),(0,i.yg)("p",null,"With the above algorithm in mind, let's introduce some examples to better understand this part of the logic."),(0,i.yg)("pre",null,(0,i.yg)("code",{parentName:"pre"},"case1:\nAmount of data 100 MB, 10 BE machines, 2TB * 3 disks\nAmount of data N = 1\nBE disks M = 10* (2TB/50GB) * 3 = 1230\nx = min(M, N, 128) = 1\nFinal: 1\n\ncase2:\nData volume 1GB, 3 BE machines, 500GB * 2 disks\nAmount of data N = 2\nBE disks M = 3* (500GB/50GB) * 2 = 60\nx = min(M, N, 128) = 2\nFinal: 2\n\ncase3:\nData volume 100GB, 3 BE machines, 500GB * 2 disks\nAmount of data N = 20\nBE disks M = 3* (500GB/50GB) * 2 = 60\nx = min(M, N, 128) = 20\nFinal: 20\n\ncase4:\nData volume 500GB, 3 BE machines, 1TB * 1 disk\nData volume N = 100\nBE disks M = 3* (1TB /50GB) * 1 = 60\nx = min(M, N, 128) = 63\nFinal: 63\n\ncase5:\nData volume 500GB, 10 BE machines, 2TB * 3 disks\nAmount of data N = 100\nBE disks M = 10* (2TB / 50GB) * 3 = 1230\nx = min(M, N, 128) = 100\nFinal: 100\n\ncase 6:\nData volume 1TB, 10 BE machines, 2TB * 3 disks\nAmount of data N = 205\nBE disks M = 10* (2TB / 50GB) * 3 = 1230\nx = min(M, N, 128) = 128\nFinal: 128\n\ncase 7:\nData volume 500GB, 1 BE machine, 100TB * 1 disk\nAmount of data N = 100\nBE disk M = 1* (100TB / 50GB) * 1 = 2048\nx = min(M, N, 128) = 100\nFinal: 100\n\ncase 8:\nData volume 1TB, 200 BE machines, 4TB * 7 disks\nAmount of data N = 205\nBE disks M = 200* (4TB / 50GB) * 7 = 114800\nx = min(M, N, 128) = 128\nFinal: 200\n")),(0,i.yg)("h3",{id:"subsequent-bucketing-projection"},"Subsequent bucketing projection"),(0,i.yg)("p",null,"The above is the calculation logic for the initial bucketing. The subsequent bucketing can be evaluated based on the amount of partition data available since there is already a certain amount of partition data. The subsequent bucket size is evaluated based on the EMA","[1]"," (short term exponential moving average) value of up to the first 7 partitions, which is used as the estimate_partition_size. At this point there are two ways to calculate the partition buckets, assuming partitioning by days, counting forward to the first day partition size of S7, counting forward to the second day partition size of S6, and so on to S1."),(0,i.yg)("ul",null,(0,i.yg)("li",{parentName:"ul"},"If the partition data in 7 days is strictly increasing daily, then the trend value will be taken at this time. There are 6 delta values, which are")),(0,i.yg)("pre",null,(0,i.yg)("code",{parentName:"pre"},"S7 - S6 = delta1,\nS6 - S5 = delta2,\n...\nS2 - S1 = delta6\n")),(0,i.yg)("p",null,"This yields the ema(delta) value.Then, today's estimate_partition_size = S7 + ema(delta)"),(0,i.yg)("ul",null,(0,i.yg)("li",{parentName:"ul"},"not the first case, this time directly take the average of the previous days EMA. Today's estimate_partition_size = EMA(S1, ... , S7) , S7)")),(0,i.yg)("admonition",{type:"tip"},(0,i.yg)("p",{parentName:"admonition"},"According to the above algorithm, the initial number of buckets and the number of subsequent buckets can be calculated. Unlike before when only a fixed number of buckets could be specified, due to changes in business data, it is possible that the number of buckets in the previous partition is different from the number of buckets in the next partition, which is transparent to the user, and the user does not need to care about the exact number of buckets in each partition, and this automatic extrapolation will make the number of buckets more reasonable.")),(0,i.yg)("h2",{id:"common-issues"},"Common Issues"),(0,i.yg)("ol",null,(0,i.yg)("li",{parentName:"ol"},(0,i.yg)("p",{parentName:"li"},"Incomplete syntax error prompts may occur in longer table creation statements. Here are some possible syntax errors for manual troubleshooting:"),(0,i.yg)("ul",{parentName:"li"},(0,i.yg)("li",{parentName:"ul"},"Syntax structure errors. Please carefully read ",(0,i.yg)("a",{parentName:"li",href:"../sql-manual/sql-reference/Data-Definition-Statements/Create/CREATE-TABLE"},"HELP CREATE TABLE"),"  and check the relevant syntax structure."),(0,i.yg)("li",{parentName:"ul"},"Reserved words. When user-defined names encounter reserved words, they need to be enclosed in backticks ``. It is recommended to use this symbol for all custom names."),(0,i.yg)("li",{parentName:"ul"},"Chinese characters or full-width characters. Non-UTF8 encoded Chinese characters or hidden full-width characters (spaces, punctuation, etc.) can cause syntax errors. It is recommended to use a text editor that displays invisible characters for inspection."))),(0,i.yg)("li",{parentName:"ol"},(0,i.yg)("p",{parentName:"li"},"Failed to create partition ","[xxx]",". Timeout"),(0,i.yg)("p",{parentName:"li"},"Doris creates tables sequentially based on partition granularity. When a partition fails to create, this error may occur. Even if partitions are not used, when there is a problem with table creation, ",(0,i.yg)("inlineCode",{parentName:"p"},"Failed to create partition")," may still be reported because, as mentioned earlier, Doris creates an unmodifiable default partition for tables without specified partitions."),(0,i.yg)("p",{parentName:"li"},"When encountering this error, it is usually because the BE encountered a problem when creating data tablets. You can troubleshoot by following these steps:"),(0,i.yg)("ul",{parentName:"li"},(0,i.yg)("li",{parentName:"ul"},"In the fe.log, search for the ",(0,i.yg)("inlineCode",{parentName:"li"},"Failed to create partition")," log entry at the corresponding timestamp. In this log entry, you may find a series of number pairs similar to ",(0,i.yg)("inlineCode",{parentName:"li"},"{10001-10010}"),". The first number in the pair represents the Backend ID, and the second number represents the Tablet ID. For example, this number pair indicates that the creation of Tablet ID 10010 on Backend ID 10001 failed.  "),(0,i.yg)("li",{parentName:"ul"},"Go to the be.INFO log of the corresponding Backend and search for tablet ID-related logs within the corresponding time period to find error messages.  "),(0,i.yg)("li",{parentName:"ul"},"Here are some common tablet creation failure errors, including but not limited to:  ",(0,i.yg)("ul",{parentName:"li"},(0,i.yg)("li",{parentName:"ul"},"The BE did not receive the relevant task. In this case, you cannot find tablet ID-related logs in be.INFO or the BE reports success but actually fails. For these issues, please refer to the ",(0,i.yg)("a",{parentName:"li",href:"../install/cluster-deployment/standard-deployment"},"Installation and Deployment")," section to check the connectivity between FE and BE.  "),(0,i.yg)("li",{parentName:"ul"},"Pre-allocated memory failure. This may be because the byte length of a row in the table exceeds 100KB.  "),(0,i.yg)("li",{parentName:"ul"},(0,i.yg)("inlineCode",{parentName:"li"},"Too many open files"),". The number of open file handles exceeds the Linux system limit. You need to modify the handle limit of the Linux system.  ")))))),(0,i.yg)("ul",null,(0,i.yg)("li",{parentName:"ul"},"If there is a timeout when creating data tablets, you can also extend the timeout by setting ",(0,i.yg)("inlineCode",{parentName:"li"},"tablet_create_timeout_second=xxx")," and ",(0,i.yg)("inlineCode",{parentName:"li"},"max_create_table_timeout_second=xxx")," in the fe.conf file. By default, ",(0,i.yg)("inlineCode",{parentName:"li"},"tablet_create_timeout_second")," is set to 1 second, and ",(0,i.yg)("inlineCode",{parentName:"li"},"max_create_table_timeout_second")," is set to 60 seconds. The overall timeout is calculated as ",(0,i.yg)("inlineCode",{parentName:"li"},"min(tablet_create_timeout_second * replication_num, max_create_table_timeout_second)"),". For specific parameter settings, please refer to the ",(0,i.yg)("a",{parentName:"li",href:"../admin-manual/config/fe-config"},"FE Configuration")," section.")),(0,i.yg)("ol",{start:3},(0,i.yg)("li",{parentName:"ol"},"The table creation command does not return results for a long time.")),(0,i.yg)("ul",null,(0,i.yg)("li",{parentName:"ul"},"Doris's table creation command is a synchronous command. The timeout for this command is currently set simply as (tablet num * replication num) seconds. If many data tablets are created and some of them fail to create, it may result in a long wait before returning an error.  "),(0,i.yg)("li",{parentName:"ul"},"Under normal circumstances, the table creation statement should return within a few seconds or tens of seconds. If it exceeds one minute, it is recommended to cancel the operation directly and check the relevant errors in the FE or BE logs.")),(0,i.yg)("h2",{id:"more-help"},"More Help"),(0,i.yg)("p",null,"For more detailed information on data partitioning, you can refer to the ",(0,i.yg)("a",{parentName:"p",href:"../sql-manual/sql-reference/Data-Definition-Statements/Create/CREATE-TABLE"},"CREATE TABLE")," command manual or enter ",(0,i.yg)("inlineCode",{parentName:"p"},"HELP CREATE TABLE;")," in the MySQL client to get more help information."))}u.isMDXComponent=!0}}]);